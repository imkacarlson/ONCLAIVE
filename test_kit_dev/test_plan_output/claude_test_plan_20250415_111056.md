# Consolidated Test Plan for Plan Net

## Generated on: 2025-04-15 11:11:16

## Capability Statement

This test plan incorporates constraints and requirements from the Plan Net Capability Statement.

## Table of Contents

- [Client](#client)
  - [REQ-02: No PII sending by clients](#req-02)
  - [REQ-06: Client handling of Must Support data elements](#req-06)
  - [REQ-07: Client display of data elements](#req-07)
  - [REQ-08: Client interpretation of missing Must Support data](#req-08)
  - [REQ-09: Client processing of missing information indicators](#req-09)
  - [REQ-31: Client tracking of directory content updates](#req-31)
- [Server](#server)
  - [REQ-01: No PII requirement for directory queries](#req-01)
  - [REQ-03: Population of Must Support data elements](#req-03)
  - [REQ-04: Not including absent data elements](#req-04)
  - [REQ-05: Using dataAbsentReason for missing required information](#req-05)
  - [REQ-10: JSON format support](#req-10)
  - [REQ-11: RESTful behavior implementation](#req-11)
  - [REQ-12: Support for all Implementation Guide profiles](#req-12)
  - [REQ-13: Unauthorized request response](#req-13)
  - [REQ-14: Insufficient scope response](#req-14)
  - [REQ-15: Invalid parameter response](#req-15)
  - [REQ-16: Unknown resource response](#req-16)
  - [REQ-17: Deleted resource response](#req-17)
  - [REQ-18: Profile identification in meta attribute](#req-18)
  - [REQ-19: Individual search parameter support](#req-19)
  - [REQ-20: Combination search parameter support](#req-20)
  - [REQ-21: Forward chaining support](#req-21)
  - [REQ-22: Reverse chaining support](#req-22)
  - [REQ-23: XML format support](#req-23)
  - [REQ-24: Rejection of unauthorized requests](#req-24)
  - [REQ-25: Support for read interaction](#req-25)
  - [REQ-26: Support for vread interaction](#req-26)
  - [REQ-27: Support for _includes](#req-27)
  - [REQ-28: Support for _revincludes](#req-28)
  - [REQ-29: Network profile NPI handling](#req-29)
  - [REQ-30: lastUpdate timestamp requirement](#req-30)
  - [REQ-32: General Search for Pharmacy](#req-32)
  - [REQ-33: Provider search by name](#req-33)
  - [REQ-34: Organization search by name](#req-34)
  - [REQ-35: Provider search by specialty](#req-35)
  - [REQ-36: Organization search by specialty](#req-36)
  - [REQ-37: Search for active practitioners and organizations](#req-37)
  - [REQ-38: Network contact handling for departments](#req-38)
  - [REQ-39: Organization contact handling for departments](#req-39)
  - [REQ-40: Practitioner qualification coding](#req-40)

## Test Specifications

<a id='client'></a>

## Client

<a id='req-02'></a>

### REQ-02: No PII sending by clients

**Description**: "A directory mobile application SHALL NOT send consumer identifiable information when querying a Plan-Net service."

**Actor**: Client

**Conformance**: SHALL NOT

# Test Specification for REQ-02

## 1. Requirement ID
REQ-02: No PII sending by clients

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically testable
- **Justification**: Network traffic and request parameters can be inspected programmatically to detect presence of PII elements

### Complexity
- **Level**: Moderate
- **Rationale**: While individual checks are simple, comprehensive PII detection across all possible request patterns requires thorough coverage

### Prerequisites
- Network traffic monitoring capability or API request logging
- Test client application configured to connect to Plan-Net service
- Definition list of PII elements to check for, including:
  - Names
  - DOB/Age
  - Contact information (phone, email, address)
  - Government IDs
  - Biometric data
  - Health plan member IDs

## 3. Test Implementation Strategy

### Required Inputs
- Test client application capable of making Plan-Net API calls
- Sample non-PII search parameters for valid requests
- Sample PII data to attempt in requests (for negative testing)

### Required FHIR Operations
Monitor all client-initiated operations including:
- GET requests with query parameters 
- POST requests with search parameters
- Any other supported search operations

### Test Cases

#### 1. Basic Parameter Validation
- **Purpose**: Verify no PII in basic URL parameters
- **Steps**:
  1. Monitor all outgoing requests from client
  2. Inspect URL parameters for PII patterns
  3. Verify no PII elements present

#### 2. Search Body Content
- **Purpose**: Verify no PII in POST search bodies
- **Steps**:
  1. Monitor POST request bodies
  2. Inspect JSON/XML content for PII patterns
  3. Verify no PII elements present

#### 3. Custom Header Validation
- **Purpose**: Verify no PII in custom headers
- **Steps**:
  1. Monitor request headers
  2. Inspect for any custom headers containing PII
  3. Verify no PII elements present

### Validation Criteria

#### Passing Criteria
- No detected PII elements in:
  - URL parameters
  - Request bodies
  - Custom headers
  - Any other request components

#### Failing Criteria
Detection of any of the following in requests:
- Personal names
- DOB/Age information
- Contact details
- Government IDs
- Health plan member IDs
- Other identifiable information

### Testing Notes
1. Implement automated pattern matching for common PII formats
2. Consider both encoded and plain text PII
3. Test boundary cases where data might look like PII but isn't
4. Document any false positives in PII detection for refinement

---

<a id='req-06'></a>

### REQ-06: Client handling of Must Support data elements

**Description**: "Application actors SHALL be capable of processing resource instances containing the Must Support data elements without generating an error or causing the application to fail."

**Actor**: Client

**Conformance**: SHALL

# Test Specification for REQ-06

## 1. Requirement ID
REQ-06: Client handling of Must Support data elements

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically testable
- **Rationale**: Can be tested by sending resources with Must Support elements and verifying client behavior

### Complexity
- **Level**: Moderate
- **Rationale**: Requires testing multiple scenarios across different resource types and Must Support elements

### Prerequisites
1. Access to client system under test
2. List of all Must Support elements defined in the IG
3. Test data containing resources with Must Support elements
4. Client system configured for testing environment
5. Ability to monitor client system behavior and error logs

## 3. Test Implementation Strategy

### Required Inputs
1. FHIR Resources:
   - Sample resources for each resource type defined in the IG
   - Each sample should include:
     - All Must Support elements populated with valid data
     - Subset of Must Support elements populated
     - Edge cases (e.g., empty strings, minimum/maximum values)

### Test Scenarios

#### Scenario 1: Basic Must Support Processing
1. Send resource instance with all Must Support elements populated
2. Verify client successfully processes without errors
3. Verify client can display/utilize Must Support elements

#### Scenario 2: Partial Must Support Elements
1. Send resource instance with only subset of Must Support elements
2. Verify client handles missing Must Support elements gracefully
3. Verify no application errors or crashes

#### Scenario 3: Edge Cases
1. Send Must Support elements with:
   - Minimum allowed values
   - Maximum allowed values
   - Empty strings (where allowed)
   - Special characters
2. Verify client processes without errors

### Validation Criteria

#### Success Criteria
1. Client application:
   - Processes resources without generating errors
   - Continues normal operation
   - Properly handles/displays Must Support elements
   - Does not crash or fail

#### Failure Criteria
1. Any of the following indicates test failure:
   - Application crashes
   - Error messages related to Must Support elements
   - Unable to process resource
   - System instability

### Test Data Requirements
1. Create test data sets:
   - Minimum valid dataset with Must Support elements
   - Complete dataset with all possible elements
   - Edge case datasets
   
### Test Steps
1. For each resource type with Must Support elements:
   ```
   a. Configure test environment
   b. Send test resource to client
   c. Monitor client behavior
   d. Verify no errors generated
   e. Verify application continues normal operation
   f. Document results
   g. Reset test environment
   ```

### Documentation Requirements
1. Test results should include:
   - Resource types tested
   - Must Support elements included
   - Client behavior observed
   - Any errors or warnings
   - Overall pass/fail status

---

<a id='req-07'></a>

### REQ-07: Client display of data elements

**Description**: "Application actors SHOULD be capable of displaying the data elements for human use or storing the information for other purposes."

**Actor**: Client

**Conformance**: SHOULD

# Test Specification for REQ-07

## 1. Requirement ID
REQ-07: Client display of data elements

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Attestation/Manual Inspection
- **Rationale**: The requirement focuses on human-visible display capabilities and general data storage, which cannot be fully automated. Manual verification through screenshots or user interface inspection is necessary.

### Complexity
- **Level**: Moderate
- **Rationale**: While the display functionality itself might be straightforward, comprehensive testing across different data elements and storage scenarios increases complexity.

### Prerequisites
1. Functional client application environment
2. Test dataset containing various FHIR resources with different data elements
3. Access to both display interface and data storage components
4. Documentation of supported data elements and their display formats

## 3. Test Implementation Strategy

### Required Inputs
1. **Test Dataset**:
   - A comprehensive set of FHIR resources containing various data types
   - Example resources should include:
     - Patient demographics
     - Observations
     - Medications
     - Conditions
     - Complex nested elements
     - Different data types (string, code, datetime, etc.)

### Testing Approach
Since this is primarily an inspection-based requirement, the testing should be conducted in multiple phases:

1. **Display Testing**:
   - Manual verification of correct rendering of all data elements
   - Screenshot documentation of various displays
   - Verification of human readability and clarity

2. **Storage Testing**:
   - Verification of data persistence
   - Confirmation of data integrity after storage
   - Documentation of storage formats and accessibility

### Validation Criteria

#### Display Validation
1. **Visual Verification**:
   - All data elements are visible and readable
   - Labels are clear and accurate
   - Data formatting is consistent
   - Special characters and extended character sets display correctly
   - Units are properly displayed where applicable

2. **Functional Verification**:
   - Navigation between different data elements works
   - Any interactive elements function as expected
   - Display adapts appropriately to different screen sizes (if applicable)

#### Storage Validation
1. **Data Persistence**:
   - Stored data matches original input
   - Data can be retrieved accurately
   - Storage format maintains data integrity

### Test Cases
1. **Basic Display Test**:
   - Load a simple Patient resource
   - Verify all fields are displayed correctly
   - Document with screenshots

2. **Complex Data Display Test**:
   - Load resources with nested elements
   - Verify hierarchy is displayed clearly
   - Document with screenshots

3. **Storage Verification Test**:
   - Store a set of resources
   - Retrieve and compare to original
   - Document storage format

### Test Documentation Requirements
1. Screenshots of displayed data elements
2. Description of storage implementation
3. List of any display or storage limitations
4. Documentation of any failed display scenarios
5. Evidence of successful data retrieval after storage

### Pass/Fail Criteria
- **Pass**: All required data elements can be displayed clearly and stored accurately
- **Partial Pass**: Minor display issues but core functionality works
- **Fail**: Major display issues or storage failures

### Notes
- This is primarily an attestation-based requirement
- Testing should be repeated for different types of data elements
- Consider accessibility requirements in display testing
- Document any assumptions about display formatting

---

<a id='req-08'></a>

### REQ-08: Client interpretation of missing Must Support data

**Description**: "When querying Health Plan API actors, Application actors SHALL interpret missing Must Support data elements within resource instances as data not present in the Health Plan API actors system."

**Actor**: Client

**Conformance**: SHALL

# Test Specification for REQ-08

## 1. Requirement ID
REQ-08: Client interpretation of missing Must Support data elements

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Attestation required
- **Rationale**: This requirement focuses on client-side interpretation behavior, which cannot be fully automated as it requires verification of how the client application handles and presents missing data to users.

### Complexity
- **Level**: Moderate
- **Rationale**: While the concept is straightforward, testing requires multiple scenarios and verification of client behavior across different Must Support elements.

### Prerequisites
1. Health Plan API test environment
2. Client application with ability to query FHIR resources
3. Test dataset containing resources with:
   - Complete Must Support elements
   - Missing Must Support elements
4. Documentation of all Must Support elements for relevant resources

## 3. Test Implementation Strategy

### Required Inputs
1. **Test Resources**:
   - At least 2 instances of each resource type containing Must Support elements
   - One instance with all Must Support elements populated
   - One instance with some Must Support elements intentionally missing

2. **Test Data Scenarios**:
```json
{
  "scenario1": {
    "resourceType": "Patient",
    "id": "test-complete",
    "name": [{
      "given": ["John"],
      "family": "Doe"
    }],
    "birthDate": "1970-01-01"
  },
  "scenario2": {
    "resourceType": "Patient",
    "id": "test-missing",
    "name": [{
      "family": "Smith"
    }]
  }
}
```

### Required FHIR Operations
1. READ operations on test resources
2. SEARCH operations that return test resources

### Validation Criteria

#### Test Cases

1. **Basic Missing Data Interpretation**
   - **Action**: Query resource with missing Must Support elements
   - **Expected**: Client displays/handles missing elements appropriately (e.g., showing "Not Available" or similar indication)
   - **Verification Method**: Manual inspection of client interface

2. **Differentiation Test**
   - **Action**: Query same resource type with both complete and missing Must Support elements
   - **Expected**: Client clearly differentiates between present and missing data
   - **Verification Method**: Manual inspection of display differences

3. **Multiple Resource Type Test**
   - **Action**: Test interpretation across different resource types
   - **Expected**: Consistent handling of missing Must Support elements across resources
   - **Verification Method**: Manual inspection across resource types

#### Attestation Checklist
- [ ] Client explicitly indicates when Must Support data is missing
- [ ] Missing data indication is consistent across all resource types
- [ ] Client does not throw errors when Must Support elements are missing
- [ ] Client documentation describes how missing Must Support elements are handled
- [ ] Client maintains consistent behavior across different API responses

#### Pass/Fail Criteria
- **Pass**: All attestation checklist items are confirmed
- **Fail**: Any of the following conditions:
  - Client throws errors when Must Support elements are missing
  - Client fails to indicate missing Must Support elements
  - Inconsistent handling of missing elements across resources
  - Misinterpretation of missing elements as having specific values

### Additional Notes
1. Test implementation should include documentation of how the client indicates missing data to end users
2. Screenshots or recordings of client behavior may be useful for attestation
3. Consider edge cases where multiple Must Support elements are missing simultaneously
4. Verify behavior across different versions of the client application if applicable

---

<a id='req-09'></a>

### REQ-09: Client processing of missing information indicators

**Description**: "Consumer App actors SHALL be able to process resource instances containing Must Support data elements asserting missing information."

**Actor**: Client

**Conformance**: SHALL

# Test Specification for REQ-09

## 1. Requirement ID
REQ-09: Client processing of missing information indicators

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically testable
- **Rationale**: Can create test scenarios with resources containing different patterns of missing data elements and verify client handling

### Complexity
- **Level**: Moderate
- **Rationale**: Requires testing multiple scenarios of missing data patterns and client-side processing verification

### Prerequisites
- Functional Client Application with FHIR capabilities
- Test environment with ability to serve FHIR resources
- Access to test data containing Must Support elements with missing information patterns
- Documentation of Must Support elements for relevant resources

## 3. Test Implementation Strategy

### Required Inputs
1. Test FHIR Resources with various missing information patterns:
   - Data Absent Reason extensions
   - Null values
   - Empty elements
   - Missing optional Must Support elements

### Test Scenarios

#### Scenario 1: Data Absent Reason Extension
```json
{
  "resourceType": "Patient",
  "id": "test-patient",
  "birthDate": {
    "extension": [{
      "url": "http://hl7.org/fhir/StructureDefinition/data-absent-reason",
      "valueCode": "unknown"
    }]
  }
}
```

#### Scenario 2: Null Values
```json
{
  "resourceType": "Observation",
  "id": "test-observation",
  "value": null
}
```

#### Scenario 3: Missing Optional Must Support Elements
```json
{
  "resourceType": "Patient",
  "id": "test-patient"
  // Must Support elements intentionally omitted
}
```

### Required FHIR Operations
1. GET operations to retrieve test resources
2. Client must demonstrate processing of each scenario

### Validation Criteria

#### For Each Scenario, Client Must:
1. Successfully parse the resource without errors
2. Display appropriate visual indication of missing data
3. Handle missing data gracefully without crashing
4. Present missing information in a user-friendly manner

#### Specific Checks:
1. **Data Absent Reason Extension**
   - Client correctly interprets and displays reason for missing data
   - UI shows appropriate placeholder or indicator

2. **Null Values**
   - Client handles null values without errors
   - UI displays appropriate placeholder

3. **Missing Optional Must Support Elements**
   - Client recognizes absence of optional elements
   - UI indicates element is not present

### Test Steps
1. Configure test environment with sample resources
2. Execute client application
3. Retrieve each test resource
4. Verify client processing for each scenario
5. Document client behavior and UI presentation
6. Validate against acceptance criteria

### Pass/Fail Criteria
- **Pass**: Client successfully processes all missing information patterns without errors and provides appropriate user feedback
- **Fail**: Any of the following:
  - Client crashes on missing data
  - Missing data not properly indicated in UI
  - Processing errors occur
  - Inappropriate handling of any missing information pattern

### Test Data Requirements
- Sample resources for each missing information pattern
- Documentation of expected client behavior
- Screenshots or recordings of correct handling

### Documentation Requirements
- Test results for each scenario
- Evidence of proper handling (screenshots)
- Any error conditions encountered
- Description of how missing information is presented to users

---

<a id='req-31'></a>

### REQ-31: Client tracking of directory content updates

**Description**: "Clients that cache query results can track additions or modifications to directory content through queries that filter content using the _lastUpdated search parameter."

**Actor**: Client

**Conformance**: None (Implementation guidance)

# Test Specification for REQ-31

## 1. Requirement ID
REQ-31: Client tracking of directory content updates

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Attestation/Manual Testing
- **Rationale**: This requirement focuses on client-side caching implementation and behavior, which cannot be automatically validated through standard FHIR testing tools. It requires verification of client behavior and implementation choices.

### Complexity
- **Level**: Moderate
- **Rationale**: While the concept is straightforward, proper implementation requires careful handling of caching logic and proper use of _lastUpdated parameter.

### Prerequisites
- Client system with caching capabilities
- FHIR server with support for _lastUpdated search parameter
- Test data set with resources that can be modified during testing
- Ability to track client-side cache state
- Timestamps for resource modifications must be maintained accurately

## 3. Test Implementation Strategy

### Required Inputs
- **Test Resources**: 
  - Minimum of 3 FHIR resources of the same type (e.g., Organizations or Practitioners)
  - Ability to modify these resources during testing
  - Known modification timestamps for resources

### Required FHIR Operations
1. Initial query without _lastUpdated parameter
2. Follow-up queries using _lastUpdated parameter with various time thresholds:
   ```
   GET [base]/[ResourceType]?_lastUpdated=gt[timestamp]
   ```

### Test Scenarios

#### Scenario 1: Initial Cache Population
1. Client performs initial query to populate cache
2. Client stores timestamp of initial query
3. Verify cache contains all returned resources

#### Scenario 2: Update Detection
1. Server updates one or more resources
2. Client queries using _lastUpdated parameter with stored timestamp
3. Verify client receives only modified resources
4. Verify client updates cache appropriately

#### Scenario 3: No Updates Present
1. Client queries using _lastUpdated with recent timestamp
2. Verify empty result handling
3. Verify cache remains unchanged

### Validation Criteria

#### Implementation Verification
1. Client must demonstrate:
   - Storage of initial query timestamp
   - Proper formation of _lastUpdated parameter in subsequent queries
   - Appropriate cache update logic

#### Functional Verification
1. Cache accuracy:
   - Cache contains all initial resources
   - Modified resources are properly updated
   - Unmodified resources remain unchanged

#### Performance Considerations
1. Client should:
   - Minimize unnecessary server queries
   - Properly handle large result sets
   - Implement appropriate cache invalidation strategy

### Test Documentation Requirements
- Record of initial cache state
- Log of _lastUpdated queries made
- Documentation of cache update logic
- Evidence of proper handling of modified resources

### Notes
- This is primarily an implementation guidance requirement rather than a strict conformance requirement
- Testing focuses on verifying proper implementation of the caching strategy
- Actual implementation details may vary by client system

---



<a id='server'></a>

## Server

<a id='req-01'></a>

### REQ-01: No PII requirement for directory queries

**Description**: "A conformant Plan-Net service SHALL NOT require a directory mobile application to send consumer identifying information in order to query content."

**Actor**: Server

**Conformance**: SHALL NOT

# Test Specification for REQ-01

## 1. Requirement ID
REQ-01: No PII requirement for directory queries

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically Testable
- **Justification**: Can be verified through systematic API testing by attempting directory queries with and without PII

### Complexity
- **Simple**
- **Rationale**: Involves straightforward API calls without complex logic or edge cases

### Prerequisites
- Access to Plan-Net FHIR server endpoint
- Test Healthcare Provider Directory data loaded on server
- Test client capable of making FHIR REST API calls
- Documentation of server's authentication requirements

## 3. Test Implementation Strategy

### Required Inputs
- Basic search parameters for directory queries (e.g., specialty, location)
- Test dataset containing:
  - Multiple Healthcare Practitioners
  - Multiple Healthcare Organizations
  - Multiple Locations

### Required FHIR Operations
Test shall include the following search operations:
1. GET [base]/Practitioner
2. GET [base]/Organization
3. GET [base]/Location
4. GET [base]/PractitionerRole

### Validation Criteria

#### Test Cases

1. **Basic Directory Query Without PII**
   - Execute searches using only non-PII parameters
   - Expected Result: Successful response with 200 OK status
   
2. **Authentication Verification**
   - Verify authentication mechanism doesn't require PII
   - Expected Result: If authentication is required, it should be based on API keys, tokens, or other non-PII methods

3. **Error Response Analysis**
   - Examine error responses for any indication of required PII
   - Expected Result: Error messages should not indicate missing PII requirements

#### Success Criteria
Test passes if ALL of the following are true:
1. Directory queries succeed without including any PII in the request
2. Server authentication (if required) does not mandate PII
3. Error responses do not indicate missing PII requirements
4. Search operations return expected results without PII requirements

#### Failure Criteria
Test fails if ANY of the following occur:
1. Server requires consumer PII in request headers
2. Server requires consumer PII as search parameters
3. Authentication mechanism requires end-user PII
4. Error responses indicate missing required PII

### Test Data Requirements
- Sample non-PII search parameters:
  ```
  specialty=cardiology
  location.address-city=Springfield
  organization.name=General Hospital
  ```

### Implementation Notes
1. Document all attempted queries and responses
2. Capture any error messages or authentication requirements
3. Verify through multiple query types to ensure comprehensive coverage
4. Test both authenticated and unauthenticated scenarios if applicable

---

<a id='req-03'></a>

### REQ-03: Population of Must Support data elements

**Description**: "Health Plan API actors SHALL be capable of populating all Must Support data elements as part of the query results."

**Actor**: Server

**Conformance**: SHALL

# Test Specification for REQ-03

## 1. Requirement ID
REQ-03: Population of Must Support Data Elements

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically testable
- **Justification**: Must Support elements can be programmatically checked for presence and valid content in server responses

### Complexity
- **Level**: Complex
- **Rationale**: 
  - Requires testing across multiple resource types
  - Needs comprehensive test data coverage
  - Must verify population of all Must Support elements

### Prerequisites
- Complete list of Must Support elements from the IG for each resource type
- Test system with FHIR server implementation
- Test data containing valid examples of all Must Support elements
- Access credentials and endpoints for the Health Plan API

## 3. Test Implementation Strategy

### Required Inputs
1. Resource test data:
   - Sample resources containing all Must Support elements
   - Resources with minimum required elements
   - Resources with optional elements

### Required FHIR Operations
1. READ operations:
   ```
   GET [base]/[ResourceType]/[id]
   ```
2. SEARCH operations:
   ```
   GET [base]/[ResourceType]?[parameters]
   ```

### Test Scenarios

#### Scenario 1: Single Resource Must Support Verification
1. For each resource type with Must Support elements:
   - Create test data including all Must Support elements
   - Submit resource to server
   - Retrieve resource and verify all Must Support elements are present

#### Scenario 2: Bulk Data Must Support Verification
1. Submit multiple resources with Must Support elements
2. Perform search operations
3. Verify Must Support elements in search results

### Validation Criteria

#### Technical Checks
1. For each Must Support element:
   - Element is present in server responses when data exists
   - Element contains valid content matching profiles
   - Element conforms to required value sets if specified

#### Success Criteria
- All Must Support elements are successfully populated in responses
- No Must Support elements are missing when relevant data exists
- Must Support elements contain valid values

#### Failure Conditions
- Missing Must Support elements in responses
- Invalid content in Must Support elements
- Server errors when requesting Must Support elements

### Test Data Requirements
1. Sample resources containing:
   - All Must Support elements populated
   - Minimum required elements
   - Edge cases for Must Support elements

### Implementation Notes
1. Create automated test suite to:
   - Track Must Support elements across resources
   - Verify element presence and content
   - Generate test reports
2. Consider implementing:
   - Element coverage tracking
   - Automated validation checks
   - Detailed error reporting

### Documentation Requirements
1. Test results should include:
   - List of tested Must Support elements
   - Coverage report
   - Any failures or issues encountered
   - Validation status for each element

This test specification provides a structured approach to verify that the Health Plan API properly implements Must Support elements across all relevant resources.

---

<a id='req-04'></a>

### REQ-04: Not including absent data elements

**Description**: "In situations where information on a particular Must Support data element is not present and the minimum cardinality is 0, the Health Plan API actors SHALL NOT include the data elements in the resource instance returned as part of the query results."

**Actor**: Server

**Conformance**: SHALL NOT

# Test Specification for REQ-04

## 1. Requirement ID
REQ-04: Not including absent data elements

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically testable
- **Reasoning**: This can be verified through automated inspection of resource responses, checking that optional Must Support elements with no values are not included in the response, rather than being included with null or empty values.

### Complexity
- **Level**: Moderate
- **Rationale**: While the concept is straightforward, testing requires:
  - Identifying all Must Support elements with min cardinality of 0
  - Creating test data with known missing values
  - Verifying correct handling across multiple resource types

### Prerequisites
- Complete list of Must Support elements with minimum cardinality of 0 for each resource type
- Test system configured with resources that intentionally have missing values for these elements
- Access to Health Plan API endpoint
- Authentication credentials if required

## 3. Test Implementation Strategy

### Required Inputs
- **Test Data**: 
  - Sample resources of each applicable type with specific Must Support elements intentionally omitted
  - Corresponding resources with the same elements present (for comparison)

### Test Scenarios
1. **Basic Absent Element Test**
   ```
   - Create resource instance missing specific Must Support elements
   - Retrieve resource via API
   - Verify absent elements are not included in response
   ```

2. **Comparison Test**
   ```
   - Create two instances of same resource type
   - One with all Must Support elements
   - One with some Must Support elements intentionally absent
   - Retrieve and compare responses
   ```

### Required FHIR Operations
- GET [base]/[ResourceType]/[id]
- GET [base]/[ResourceType]?[search parameters]

### Validation Criteria

#### Positive Assertions
1. Response resources MUST NOT contain Must Support elements when:
   - The element has min cardinality of 0
   - No value exists for that element

#### Negative Assertions
1. Response resources MUST NOT:
   - Include empty arrays for absent elements
   - Include null values for absent elements
   - Include empty strings for absent elements

### Test Steps
1. Setup Phase:
   ```
   - Identify test resource type(s)
   - Create test resource instance(s) with specific Must Support elements omitted
   - Store resource(s) in test system
   ```

2. Execution Phase:
   ```
   - Execute GET request for resource(s)
   - Capture response
   ```

3. Validation Phase:
   ```
   - Parse response JSON
   - Check for presence of any Must Support elements that should be absent
   - Verify no empty/null representations are included
   - Document results
   ```

### Success Criteria
- Test passes if:
  1. Response contains expected resource data
  2. Response does NOT contain any representation of intentionally omitted Must Support elements
  3. No errors are returned due to missing elements

### Edge Cases to Consider
1. Partial data scenarios
2. Arrays with some elements present and others absent
3. Nested objects with missing optional elements
4. Multiple cardinality elements

### Test Data Requirements
- Sample resources must include:
  1. Complete valid resources (control)
  2. Resources with specific Must Support elements intentionally omitted
  3. Resources with combinations of present and absent elements

---

<a id='req-05'></a>

### REQ-05: Using dataAbsentReason for missing required information

**Description**: "In situations where information on a particular data element is not present and the minimum cardinality is >0, SHALL send the reason for the missing information using values (such as nullFlavors) from the value set where they exist or use the dataAbsentReason extension."

**Actor**: Server

**Conformance**: SHALL

# Test Specification for REQ-05

## 1. Requirement ID
REQ-05: Using dataAbsentReason for missing required information

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically testable
- **Reasoning**: Can be verified through automated testing of resource instances by checking for the presence of dataAbsentReason when required elements are missing

### Complexity
- **Level**: Moderate
- **Reasoning**: Requires testing multiple scenarios across different resource types and checking proper use of dataAbsentReason extension

### Prerequisites
- Test environment with FHIR server implementation
- Access to create and query FHIR resources
- Sample resources with required elements (min cardinality >0)
- Value sets containing applicable nullFlavor codes

## 3. Test Implementation Strategy

### Test Scenarios

1. **Basic Required Element Test**
   ```
   Given a FHIR resource with a required element
   When the required element value is missing
   Then the dataAbsentReason extension SHALL be present
   And the extension SHALL contain a valid reason code
   ```

2. **Value Set NullFlavor Test**
   ```
   Given a FHIR resource with a required element that has associated nullFlavor values
   When the required element is missing
   Then the dataAbsentReason SHALL use an appropriate nullFlavor from the value set
   ```

### Required Inputs

1. **Test Resources**
   - Patient resource with missing name (required element)
   - Observation resource with missing status (required element)
   - Condition resource with missing code (required element)

2. **Sample DataAbsentReason Codes**
   - unknown
   - asked-unknown
   - temp-unknown
   - not-asked
   - masked
   - not-applicable
   - unsupported

### Required FHIR Operations
- POST/PUT operations to create/update resources
- GET operations to retrieve and verify resources

### Validation Criteria

#### Technical Checks
1. Verify presence of dataAbsentReason extension when required elements are missing
   ```json
   {
     "resourceType": "Patient",
     "id": "example",
     "name": [{
       "extension": [{
         "url": "http://hl7.org/fhir/StructureDefinition/data-absent-reason",
         "valueCode": "unknown"
       }]
     }]
   }
   ```

2. Validate that dataAbsentReason codes are from approved value sets
3. Confirm extension structure is correct:
   - Correct URL: "http://hl7.org/fhir/StructureDefinition/data-absent-reason"
   - Valid valueCode

#### Test Assertions
1. Resources with missing required elements MUST include dataAbsentReason
2. DataAbsentReason extensions MUST use valid codes
3. When value set specific nullFlavors exist, they MUST be used instead of generic dataAbsentReason codes

### Edge Cases to Test
1. Multiple missing required elements in same resource
2. Resources with both present and missing required elements
3. Updates that remove required elements
4. Invalid dataAbsentReason codes
5. Missing dataAbsentReason when required element is absent

### Test Data Generation
```javascript
const testCases = [
  {
    resource: "Patient",
    missingElement: "name",
    dataAbsentReason: "unknown",
    expectedResult: "pass"
  },
  {
    resource: "Observation",
    missingElement: "status",
    dataAbsentReason: "not-applicable",
    expectedResult: "pass"
  },
  {
    resource: "Patient",
    missingElement: "name",
    dataAbsentReason: null, // Missing dataAbsentReason
    expectedResult: "fail"
  }
];
```

### Success Criteria
- All test assertions pass
- No validation errors related to missing required elements without dataAbsentReason
- Proper use of value set-specific nullFlavors where applicable
- Correct extension structure and codes in all cases

---

<a id='req-10'></a>

### REQ-10: JSON format support

**Description**: "Support json source formats for all Plan-Net interactions."

**Actor**: Server

**Conformance**: SHALL

# Test Specification for REQ-10

## 1. Requirement ID
REQ-10: JSON Format Support

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically Testable
- **Rationale**: This can be verified through automated testing by making HTTP requests with appropriate headers and analyzing responses

### Complexity
- **Level**: Simple
- **Rationale**: Testing JSON format support is straightforward using standard HTTP interactions and content-type headers

### Prerequisites
- FHIR server endpoint must be available and operational
- Server must implement at least one Plan-Net resource type
- Test client capable of making HTTP requests with specific content-type headers

## 3. Test Implementation Strategy

### Required Inputs
- List of all supported Plan-Net resource endpoints from the server
- Sample valid FHIR resources for each supported resource type in JSON format
- HTTP client capable of setting request headers

### Required FHIR Operations
For each supported resource type, test:
1. READ operation: `GET [base]/[resource-type]/[id]`
2. SEARCH operation: `GET [base]/[resource-type]?[parameters]`
3. CREATE operation (if supported): `POST [base]/[resource-type]`
4. UPDATE operation (if supported): `PUT [base]/[resource-type]/[id]`

### Validation Criteria

#### Test Case 1: JSON Response Format
1. Send GET request with header `Accept: application/fhir+json`
2. **Assertions**:
   - Response status code should be 200 OK
   - Response Content-Type header should be `application/fhir+json`
   - Response body should be valid JSON
   - Response body should be valid FHIR JSON structure

#### Test Case 2: JSON Request Format
1. Send POST/PUT request with:
   - Header `Content-Type: application/fhir+json`
   - Valid FHIR resource in JSON format
2. **Assertions**:
   - Response status code should be 201 Created (POST) or 200 OK (PUT)
   - Server should accept and process the JSON request successfully

#### Test Case 3: Format Negotiation
1. Send request without specific Accept header
2. **Assertions**:
   - Server should default to JSON format
   - Response Content-Type should be `application/fhir+json`

#### Test Case 4: Error Handling
1. Send request with invalid format specification
2. **Assertions**:
   - Server should respond with appropriate error status code
   - Error response should be in JSON format

### Expected Outputs
- All responses should be valid FHIR JSON format
- Content-Type headers in responses should indicate JSON format
- Successful HTTP status codes (200, 201) for valid requests
- Appropriate error codes for invalid requests
- All JSON responses should validate against FHIR JSON schema

### Test Data Requirements
- Sample valid FHIR resources in JSON format
- Sample invalid format requests
- List of supported resource types from capability statement

---

<a id='req-11'></a>

### REQ-11: RESTful behavior implementation

**Description**: "Implement the RESTful behavior according to the FHIR specification."

**Actor**: Server

**Conformance**: SHALL

# Test Specification for REQ-11

## 1. Requirement ID
REQ-11: RESTful behavior implementation

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically testable 
- **Rationale**: While broad in scope, the RESTful behaviors defined in the FHIR specification are concrete and testable through API interactions

### Complexity
- **Complex**
- **Rationale**: Testing complete RESTful behavior requires verification of multiple interactions, status codes, headers, and edge cases

### Prerequisites
- Server must be operational and accessible via HTTP/HTTPS
- Test client with ability to make HTTP requests
- Valid authentication credentials (if required)
- Test data for various resources

## 3. Test Implementation Strategy

### Required Inputs
- Set of test FHIR resources covering common resource types
- Invalid resources for error handling tests
- Search parameters for testing search operations
- Version identifiers for history operations

### Required FHIR Operations
Basic RESTful operations to test:
1. Instance Level:
   - READ: GET [base]/[resourceType]/[id]
   - UPDATE: PUT [base]/[resourceType]/[id]
   - DELETE: DELETE [base]/[resourceType]/[id]
   - CREATE: POST [base]/[resourceType]

2. Type Level:
   - SEARCH: GET [base]/[resourceType]?[parameters]
   - HISTORY: GET [base]/[resourceType]/_history
   - CREATE: POST [base]/[resourceType]

### Validation Criteria

#### 1. HTTP Method Support
- **Test**: Verify supported HTTP methods
- **Expected**: Server responds appropriately to each HTTP method
- **Assertions**:
  - GET returns 200 OK for existing resources
  - POST returns 201 Created for successful resource creation
  - PUT returns 200 OK for successful updates
  - DELETE returns 204 No Content for successful deletions

#### 2. Content Negotiation
- **Test**: Verify proper content type handling
- **Expected**: Server handles Accept headers correctly
- **Assertions**:
  - Responds with requested format (application/fhir+json or application/fhir+xml)
  - Returns 406 Not Acceptable for unsupported formats

#### 3. Resource Versioning
- **Test**: Verify version handling
- **Expected**: Server maintains resource versions
- **Assertions**:
  - ETag header present in responses
  - Version-aware updates work correctly
  - History operation returns version history

#### 4. Search Implementation
- **Test**: Verify search functionality
- **Expected**: Server implements search according to FHIR spec
- **Assertions**:
  - Handles standard search parameters
  - Returns proper search bundle
  - Implements _include and _revinclude if supported
  - Supports chained parameters if specified

#### 5. Error Handling
- **Test**: Verify proper error responses
- **Expected**: Server returns appropriate error status codes and OperationOutcome resources
- **Assertions**:
  - 404 Not Found for non-existent resources
  - 400 Bad Request for invalid parameters
  - 422 Unprocessable Entity for invalid content
  - OperationOutcome contains meaningful error details

#### 6. Conditional Operations
- **Test**: Verify conditional create/update/delete
- **Expected**: Server handles conditional headers correctly
- **Assertions**:
  - If-None-Exist header works for conditional create
  - If-Match/If-None-Match headers work for updates
  - Conditional delete operates correctly

#### 7. Response Format
- **Test**: Verify response formatting
- **Expected**: Responses conform to FHIR specification
- **Assertions**:
  - Resource responses include proper metadata
  - Bundle responses have correct structure
  - Required headers present (Content-Type, Location for creates)

This test specification provides a comprehensive framework for verifying RESTful behavior compliance. Each section should be implemented as discrete test cases, with detailed step-by-step procedures developed for each assertion.

---

<a id='req-12'></a>

### REQ-12: Support for all Implementation Guide profiles

**Description**: "Support all profiles defined in this Implementation Guide."

**Actor**: Server

**Conformance**: SHALL

# Test Specification for REQ-12

## 1. Requirement ID
REQ-12: Support for all Implementation Guide profiles

## 2. Requirement Analysis

### Testability Assessment
Automatically testable through a combination of validator checks and API testing

### Complexity 
Complex - requires testing multiple profiles and their constraints

### Prerequisites
- Access to complete list of profiles defined in the Implementation Guide
- FHIR server endpoint configured and accessible
- Test data conforming to each profile's requirements
- FHIR validator with the Implementation Guide loaded

## 3. Test Implementation Strategy

### Required Inputs
- One or more valid resource instances for each profile defined in the IG
- Invalid resource instances that violate profile constraints (for negative testing)

### Required FHIR Operations
For each profile defined in the IG:
1. `CREATE` operation to test profile creation
2. `READ` operation to verify retrieved resources conform to profiles
3. `SEARCH` operation to verify search results conform to profiles

### Validation Criteria

#### Profile Support Testing
For each profile in the IG:

1. Resource Creation Test
   - Create a valid resource instance conforming to the profile
   - Expected: Server accepts the resource and returns 201 Created
   - Verify the returned resource maintains profile conformance

2. Resource Retrieval Test
   - Retrieve the created resource via GET
   - Expected: Server returns 200 OK with resource conforming to profile
   - Validate returned resource against profile structure definition

3. Search Results Test
   - Execute search that should return resources of the profile type
   - Expected: All returned resources should declare conformance to the profile
   - Validate each returned resource against profile requirements

4. Profile Rejection Test
   - Attempt to create resource that violates profile constraints
   - Expected: Server should reject with 400 Bad Request
   - Verify error message indicates profile validation failure

#### General Assertions
- All resources of relevant types must declare conformance to appropriate profiles
- Server must enforce all profile constraints during resource creation/updates
- Server must maintain profile conformance in all operations
- Search results must return profile-conformant resources

#### Pass/Fail Criteria
Test passes if:
1. All profile-conformant resources are accepted
2. Non-conformant resources are rejected
3. Retrieved resources maintain profile conformance
4. Search results contain profile-conformant resources
5. Validator confirms conformance for all returned resources

Test fails if any of the above criteria are not met for any profile defined in the IG.

### Notes
- Consider implementing test cases for each profile sequentially
- Maintain test data sets that exercise all required elements and constraints
- Document any profile-specific requirements or dependencies
- Consider impact of must-support elements in testing strategy

---

<a id='req-13'></a>

### REQ-13: Unauthorized request response

**Description**: "Return the following response classes: (Status 401/4xx): unauthorized request."

**Actor**: Server

**Conformance**: SHALL

# Test Specification for REQ-13

## 1. Requirement ID
REQ-13: Unauthorized Request Response Testing

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically Testable
- **Rationale**: The requirement specifies a clear technical behavior that can be verified through automated API testing - returning a 401 status code for unauthorized requests.

### Complexity
- **Level**: Simple
- **Rationale**: Testing unauthorized access is a fundamental security check with clear expected outcomes.

### Prerequisites
1. A running FHIR server implementation
2. Test client capable of making FHIR API requests
3. Authentication mechanism configured on the server
4. Valid and invalid authentication credentials for testing

## 3. Test Implementation Strategy

### Required Inputs
1. Invalid/missing authentication credentials
2. Valid FHIR endpoint URLs for testing
3. Sample FHIR resources for attempted access

### Required FHIR Operations
Test should cover common FHIR interactions:
- READ
- SEARCH
- CREATE
- UPDATE
- DELETE

### Test Cases

#### TC1: Missing Authentication
1. Make requests with no authentication headers
2. Expected: 401 response

#### TC2: Invalid Authentication Token
1. Make requests with malformed/expired authentication token
2. Expected: 401 response

#### TC3: Invalid Credentials
1. Make requests with incorrect username/password combination
2. Expected: 401 response

### Validation Criteria

#### Primary Assertions
1. Response Status Code MUST be 401
2. Response Headers MUST include:
   - `WWW-Authenticate` header
   - Appropriate CORS headers if applicable

#### Response Body Validation
1. Response MUST contain an OperationOutcome resource
2. OperationOutcome MUST include:
   - Appropriate error code
   - Human-readable error message
   - Issue severity of "error"

### Test Data Requirements
```json
{
  "invalidToken": "Bearer invalid_token_string",
  "malformedToken": "InvalidTokenFormat",
  "noAuth": ""
}
```

### Sample Test Flow
1. Configure test client with invalid authentication
2. Attempt to access protected FHIR resources
3. Verify 401 response
4. Validate response headers and body
5. Repeat for each authentication failure scenario

### Error Conditions to Test
1. Missing authentication headers
2. Expired tokens
3. Malformed tokens
4. Invalid credentials
5. Insufficient permissions

## Additional Notes
- Tests should be executed against all relevant FHIR endpoints
- Implementation should include proper test cleanup
- Consider rate limiting implications during testing
- Document any specific authentication implementation details

---

<a id='req-14'></a>

### REQ-14: Insufficient scope response

**Description**: "Return the following response classes: (Status 403): insufficient scope."

**Actor**: Server

**Conformance**: SHALL

# Test Specification for REQ-14

## 1. Requirement ID
REQ-14: Insufficient scope response verification

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically Testable
- **Rationale**: This requirement involves a specific HTTP response code that can be programmatically verified

### Complexity
- **Level**: Moderate
- **Rationale**: Requires OAuth 2.0 setup and testing with different scopes, but has clear pass/fail criteria

### Prerequisites
- OAuth 2.0 authentication framework must be implemented on the server
- Test client with ability to authenticate using OAuth 2.0
- Ability to configure/obtain access tokens with different scopes
- Test environment with protected resources requiring specific scopes

## 3. Test Implementation Strategy

### Required Inputs
1. Valid OAuth 2.0 access token with insufficient scope
2. Protected FHIR resource endpoint(s) that require specific scopes
3. Valid authentication credentials

### Required FHIR Operations
1. Any FHIR REST operation (GET, POST, PUT, DELETE) against a protected endpoint
   Example operations:
   - GET [base]/Patient
   - GET [base]/Observation
   - POST [base]/Patient

### Validation Criteria

#### Test Cases

1. **Basic Insufficient Scope Test**
   - Setup: 
     * Configure access token with scope that doesn't match required resource scope
   - Action:
     * Perform FHIR operation on protected resource
   - Expected Result:
     * HTTP Status Code: 403 Forbidden
     * Response body should contain appropriate error details

2. **Multiple Resources Scope Test**
   - Setup:
     * Configure access token with partial scopes (e.g., read but not write)
   - Action:
     * Attempt operations requiring higher privileges
   - Expected Result:
     * HTTP Status Code: 403 Forbidden for operations exceeding scope
     * Success for operations within scope

#### Specific Assertions
1. Verify HTTP response code is exactly 403
2. Verify response contains appropriate OperationOutcome resource
3. Verify error message indicates insufficient scope issue
4. Verify response headers include proper security headers
5. Verify same response pattern across different resource types

### Error Scenarios to Test
1. Token with no scopes
2. Token with read-only scope attempting write operation
3. Token with scope for one resource type accessing different resource type
4. Expired token with otherwise sufficient scope

### Test Data Requirements
1. Various OAuth 2.0 access tokens with different scope configurations
2. Test resources that require different levels of scope access
3. Valid but scope-restricted user credentials

This test specification ensures comprehensive verification of the server's handling of insufficient scope scenarios while maintaining security best practices.

---

<a id='req-15'></a>

### REQ-15: Invalid parameter response

**Description**: "Return the following response classes: (Status 400): invalid parameter."

**Actor**: Server

**Conformance**: SHALL

# Test Specification for REQ-15: Invalid Parameter Response

## 1. Requirement ID
REQ-15

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically Testable
- **Rationale**: The requirement involves testing a specific HTTP response code (400) which can be programmatically verified

### Complexity
- **Level**: Moderate
- **Rationale**: While testing HTTP 400 responses is straightforward, comprehensive testing requires multiple test cases covering various invalid parameter scenarios

### Prerequisites
- FHIR server must be operational and accessible
- Server must support standard FHIR RESTful operations
- Test client capable of making FHIR API calls and validating responses
- Access credentials if required

## 3. Test Implementation Strategy

### Required Inputs
1. Set of FHIR API requests with invalid parameters:
   - Invalid search parameters
   - Malformed parameter values
   - Out-of-range values
   - Incorrect data types
   - Invalid format specifications

### Required FHIR Operations
1. GET operations with invalid parameters
   Example scenarios:
   - `/Patient?birthdate=invalid-date`
   - `/Patient?_count=abc`
   - `/Patient?gender=invalidgender`
   
2. POST/PUT operations with invalid parameters in body
   Example scenarios:
   - Malformed JSON/XML
   - Invalid resource attributes

### Validation Criteria

#### Primary Assertions
1. HTTP Status Code MUST be 400
2. Response MUST include an OperationOutcome resource
3. OperationOutcome MUST contain:
   - At least one issue element
   - Clear error message describing the invalid parameter

#### Test Cases

1. **Invalid Search Parameter Test**
```
GET [base]/Patient?invalidParameter=value
Expected: 400 Bad Request
```

2. **Invalid Date Format Test**
```
GET [base]/Patient?birthdate=2023-13-32
Expected: 400 Bad Request
```

3. **Invalid Enumeration Value Test**
```
GET [base]/Patient?gender=invalid
Expected: 400 Bad Request
```

4. **Invalid Number Format Test**
```
GET [base]/Patient?_count=abc
Expected: 400 Bad Request
```

5. **Multiple Invalid Parameters Test**
```
GET [base]/Patient?invalidParam1=value&invalidParam2=value
Expected: 400 Bad Request
```

### Success Criteria
Test passes if ALL of the following are true for each test case:
1. Server returns HTTP 400 status code
2. Response includes OperationOutcome resource
3. OperationOutcome contains meaningful error description
4. No server crashes or unexpected behaviors occur

### Edge Cases to Consider
1. Empty parameter values
2. Special characters in parameter values
3. Extremely long parameter values
4. Unicode characters in parameter values
5. Multiple invalid parameters in single request

### Test Data Requirements
1. No specific test data needed in the server
2. Test client must be configured to send invalid parameter requests
3. List of valid parameter names but invalid values
4. List of completely invalid parameter names

This test specification provides a comprehensive approach to validating the server's handling of invalid parameters, ensuring robust error handling and appropriate client feedback.

---

<a id='req-16'></a>

### REQ-16: Unknown resource response

**Description**: "Return the following response classes: (Status 404): unknown resource."

**Actor**: Server

**Conformance**: SHALL

# Test Specification for REQ-16

## 1. Requirement ID
REQ-16 - Unknown Resource Response Testing

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically Testable
- **Rationale**: The requirement specifies a clear expected behavior that can be validated through automated HTTP requests and response validation

### Complexity
- **Simple**
- **Rationale**: Involves straightforward HTTP request/response testing with a specific expected status code

### Prerequisites
- FHIR server endpoint must be available and accessible
- Server must be configured to handle resource requests
- No specific test data needs to be pre-loaded

## 3. Test Implementation Strategy

### Required Inputs
- FHIR server base URL
- Non-existent resource type and ID combinations for testing
- Example test cases:
  1. `GET [base]/Patient/nonexistent-id`
  2. `GET [base]/Observation/nonexistent-id`
  3. `GET [base]/Encounter/nonexistent-id`

### Required FHIR Operations
- HTTP GET operations for individual resource retrieval
- No special FHIR operations required beyond basic RESTful GET

### Test Cases

#### Test Case 1: Known Resource Type with Non-existent ID
```
GET [base]/Patient/nonexistent-12345
Expected: 404 Not Found
```

#### Test Case 2: Unknown Resource Type
```
GET [base]/NonExistentResource/12345
Expected: 404 Not Found
```

### Validation Criteria

#### HTTP Response Validation
1. Status Code Check:
   - MUST return HTTP 404 status code
   
2. Response Headers:
   - SHOULD include Content-Type: application/fhir+json (or xml)
   
3. Response Body (if present):
   - SHOULD contain a FHIR OperationOutcome resource
   - SHOULD include an appropriate error message indicating resource not found

#### Success Criteria
- All test cases must return HTTP 404
- Response format must be valid FHIR
- Error messaging should be appropriate for resource not found scenario

### Error Conditions to Test
1. Non-existent resource IDs
2. Invalid/non-existent resource types
3. Malformed resource URLs

### Implementation Notes
- Test automation should include error handling for network issues
- Tests should verify both the status code and response format
- Implementation should include appropriate logging for troubleshooting
- Consider testing with both JSON and XML formats if supported

### Test Data Requirements
- No specific test data needs to be pre-loaded
- Test cases should use predictably non-existent resource IDs

### Limitations and Assumptions
- Server is available and accessible
- Server implements basic FHIR RESTful API
- Network connectivity is stable
- Server supports JSON and/or XML formats

---

<a id='req-17'></a>

### REQ-17: Deleted resource response

**Description**: "Return the following response classes: (Status 410): deleted resource."

**Actor**: Server

**Conformance**: SHALL

# Test Specification for REQ-17

## 1. Requirement ID
REQ-17: Deleted Resource Response Handling

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically Testable
- **Rationale**: This requirement can be tested through automated HTTP requests and response validation

### Complexity
- **Simple**
- **Rationale**: Involves straightforward HTTP response code validation for a specific scenario

### Prerequisites
1. FHIR server must be running and accessible
2. At least one resource that can be created and then deleted
3. Access credentials if required
4. Ability to perform DELETE operations on resources

## 3. Test Implementation Strategy

### Required Inputs
1. Test Resource:
   - A FHIR resource (e.g., Patient) that will be:
     - Created initially
     - Deleted 
     - Subsequently requested

### Required FHIR Operations
1. `POST [base]/[resourceType]` - To create initial resource
2. `DELETE [base]/[resourceType]/[id]` - To delete the resource
3. `GET [base]/[resourceType]/[id]` - To attempt retrieval of deleted resource

### Test Sequence
1. **Setup Phase**
   ```
   - Create test resource
   - Store resource ID
   - Delete resource using DELETE operation
   ```

2. **Test Phase**
   ```
   - Attempt to retrieve deleted resource using GET operation
   - Verify response status code is 410 Gone
   ```

### Validation Criteria
1. **Primary Assertion**
   - Response status code MUST be 410 (Gone)

2. **Additional Validations**
   - Response headers should indicate content type if body is returned
   - If OperationOutcome is returned in body:
     - Should contain appropriate error details
     - Should be valid FHIR JSON/XML

### Sample Test Cases

#### Test Case 1: Basic Deleted Resource Response
```
- Create Patient resource
- Delete Patient resource
- GET deleted Patient resource
- Assert 410 status code
```

#### Test Case 2: Multiple Resource Types
```
- Repeat Test Case 1 with different resource types (Observation, Condition, etc.)
- Assert 410 status code for each
```

### Edge Cases to Consider
1. Attempting to access never-existed resource
2. Attempting to access resource with invalid ID format
3. Multiple consecutive attempts to access deleted resource

### Error Conditions
- Document behavior if server responds with different status code
- Check if appropriate security headers are present
- Verify proper error handling for unauthorized access

### Test Data Requirements
- Sample resources for creation/deletion
- Invalid resource IDs
- Invalid resource types

### Reporting Requirements
1. Test execution timestamp
2. Resource types tested
3. Response status codes received
4. Any OperationOutcome details
5. Overall pass/fail status

---

<a id='req-18'></a>

### REQ-18: Profile identification in meta attribute

**Description**: "Identify the Plan-Net profiles supported as part of the FHIR meta.profile attribute for each instance."

**Actor**: Server

**Conformance**: SHALL

# Test Specification for REQ-18

## 1. Requirement ID
REQ-18: Profile identification in meta attribute

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically testable
- **Rationale**: The presence and content of the meta.profile attribute can be programmatically verified through automated testing

### Complexity
- **Level**: Simple
- **Rationale**: Involves straightforward validation of a single attribute across resource instances

### Prerequisites
- Server must be operational and accessible
- Server must support Plan-Net profiles
- Sample data containing Plan-Net profiled resources must be available on the server
- List of valid Plan-Net profile URLs must be known for validation

## 3. Test Implementation Strategy

### Required Inputs
- List of valid Plan-Net profile URLs
- Set of resource instances to test against
- Access to FHIR server endpoints

### Required FHIR Operations
- READ operations on relevant Plan-Net resources
- SEARCH operations to retrieve collections of resources

### Test Cases

#### Test Case 1: Verify Meta Profile Presence
1. Perform READ/SEARCH operations to retrieve Plan-Net resources
2. For each returned resource:
   - Verify meta element exists
   - Verify meta.profile element exists
   - Verify meta.profile contains at least one valid Plan-Net profile URL

#### Test Case 2: Verify Profile URL Validity
1. For each meta.profile value:
   - Validate that the URL matches the expected format for Plan-Net profile URLs
   - Confirm URL corresponds to a known Plan-Net profile

### Validation Criteria

#### Pass Criteria
- All retrieved resources MUST contain a meta element
- meta.profile MUST be present
- meta.profile MUST contain at least one valid Plan-Net profile URL
- Profile URLs MUST be properly formatted
- Profile URLs MUST reference valid Plan-Net profiles

#### Fail Criteria
- Resources missing meta element
- Resources missing meta.profile element
- Invalid or missing profile URLs
- Profile URLs that don't correspond to Plan-Net profiles

### Sample Test Script Pseudocode
```
for each resource in server.getResources():
    assert resource.meta exists
    assert resource.meta.profile exists
    assert resource.meta.profile.length > 0
    
    for profileUrl in resource.meta.profile:
        assert profileUrl matches Plan-Net-URL-Pattern
        assert profileUrl in ValidPlanNetProfiles
```

### Test Data Requirements
- Minimum of one instance of each Plan-Net profiled resource type
- Mix of resources with single and multiple profile references
- Example of valid Plan-Net profile URLs for validation

### Additional Notes
- Consider implementing as part of automated test suite
- May need to be combined with profile validation testing
- Document any profile URL patterns specific to Plan-Net for validation

---

<a id='req-19'></a>

### REQ-19: Individual search parameter support

**Description**: "Support the searchParameters on each profile individually."

**Actor**: Server

**Conformance**: SHALL

# Test Specification for REQ-19

## 1. Requirement ID
REQ-19: Individual Search Parameter Support

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically Testable
- **Justification**: Search parameter support can be systematically tested through API calls and validation of responses

### Complexity
- **Level**: Complex
- **Rationale**: Requires testing multiple search parameters across different profiles, with various data combinations

### Prerequisites
- Full list of supported profiles from the Implementation Guide
- Sample test data for each profile that includes variations to test different search parameters
- Documentation of valid search parameters for each profile
- Server endpoint configured and accessible
- Authentication credentials if required

## 3. Test Implementation Strategy

### Required Inputs
- Test dataset containing resources for each supported profile
- Matrix of search parameters defined for each profile
- Expected result sets for each search parameter test

### Required FHIR Operations
For each supported profile:
1. `GET [base]/[ResourceType]?[parameter]=[value]`
2. `GET [base]/[ResourceType]?[parameter1]=[value1]&[parameter2]=[value2]` (for combination tests)

### Test Scenarios

#### Basic Search Parameter Testing
1. **Single Parameter Tests**
   - For each profile:
     - Test each defined search parameter individually
     - Verify response includes expected matches
     - Verify response format conforms to FHIR specification

2. **Combination Parameter Tests**
   - For each profile:
     - Test logical combinations of multiple search parameters
     - Verify AND logic works correctly
     - Verify no unexpected results are returned

3. **Edge Cases**
   - Empty result sets
   - Invalid parameter values
   - Special characters in search values
   - Maximum length values

### Validation Criteria

#### Technical Checks
1. **Response Status**
   - 200 OK for successful searches
   - 400 Bad Request for invalid parameters
   - 403 Forbidden for unauthorized searches (if applicable)

2. **Response Format**
   - Valid FHIR Bundle
   - Correct count of returned resources
   - Proper resource types returned

3. **Search Parameter Behavior**
   - Correct filtering based on search criteria
   - Proper handling of partial matches (where applicable)
   - Correct implementation of modifiers (if supported)

#### Functional Validation
1. **Completeness**
   - All documented search parameters are implemented
   - Each parameter returns expected results
   - No undocumented parameters are exposed

2. **Accuracy**
   - Search results match the search criteria
   - No false positives in results
   - No missing results that should match

### Test Data Requirements
1. **Base Dataset**
   - Minimum of 3 resources per profile
   - Resources with varying values for each search parameter
   - Resources with edge case values

2. **Expected Results**
   - Documented expected result sets for each test case
   - Expected error responses for invalid scenarios

### Reporting Requirements
- Parameter support matrix showing test results for each profile
- List of any unsupported parameters
- Documentation of any deviations from expected behavior
- Performance metrics (optional)

This test specification provides a framework for comprehensive validation of search parameter support across all profiles. Implementation teams should adapt the specific test cases based on their supported profiles and parameters.

---

<a id='req-20'></a>

### REQ-20: Combination search parameter support

**Description**: "Support the searchParameters on each profile in combination."

**Actor**: Server

**Conformance**: SHALL

# Test Specification for REQ-20

## 1. Requirement ID
REQ-20: Combination Search Parameter Support

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically Testable
- **Justification**: Search parameter combinations can be systematically tested through API calls and response validation

### Complexity
- **Level**: Complex
- **Rationale**: Must test multiple combinations of search parameters across different profiles, requiring extensive test cases and validation scenarios

### Prerequisites
- Server must be operational and accessible
- Test data must include resources with various searchable attributes
- All profiles referenced in the IG must be available
- Knowledge of all valid search parameters for each profile

## 3. Test Implementation Strategy

### Required Inputs
1. Collection of test FHIR resources representing each profile
2. Complete list of supported search parameters for each profile
3. Valid values for each search parameter

### Required FHIR Operations
1. GET operations with multiple search parameters
2. Format: `GET [base]/[ResourceType]?param1=value1&param2=value2`

### Test Cases

#### Basic Combination Tests
1. Two Parameter Combinations
```
Test Case TC-20.1
- Operation: GET [base]/[ResourceType]?param1=value1&param2=value2
- Expected: Server returns matching resources
- Validation: Response contains only resources matching both criteria
```

2. Three Parameter Combinations
```
Test Case TC-20.2
- Operation: GET [base]/[ResourceType]?param1=value1&param2=value2&param3=value3
- Expected: Server returns matching resources
- Validation: Response contains only resources matching all three criteria
```

#### Edge Cases
1. Invalid Combination Test
```
Test Case TC-20.3
- Operation: GET [base]/[ResourceType] with invalid parameter combination
- Expected: Server returns appropriate error response
- Validation: Error message indicates invalid parameter combination
```

2. Empty Result Set
```
Test Case TC-20.4
- Operation: GET [base]/[ResourceType] with valid but non-matching combination
- Expected: Server returns empty bundle
- Validation: Bundle contains zero entries but is valid
```

### Validation Criteria

1. Response Format
- Returns valid FHIR Bundle
- Appropriate HTTP status codes (200 for success, 400 for invalid parameters)

2. Content Validation
- All returned resources match ALL search criteria
- Pagination properly maintained for large result sets
- Search parameters properly processed (no ignored parameters)

3. Performance Validation
- Response times within acceptable limits
- Proper handling of large result sets

### Implementation Notes

1. Test Data Requirements
- Create test data covering all possible search parameter combinations
- Include edge cases and boundary conditions
- Document expected results for each combination

2. Error Handling
- Verify appropriate error responses for invalid combinations
- Check error message clarity and usefulness
- Validate HTTP status codes

3. Documentation Requirements
- Document all tested combinations
- Record actual vs expected results
- Note any limitations or unexpected behaviors

4. Test Execution
- Execute tests with varying load conditions
- Test with different parameter value types (exact, contains, etc.)
- Verify behavior with special characters and edge cases

---

<a id='req-21'></a>

### REQ-21: Forward chaining support

**Description**: "Support forward chaining on all search parameters that specify the 'chain' property."

**Actor**: Server

**Conformance**: SHALL

# Test Specification for REQ-21: Forward Chaining Support

## 1. Requirement ID
REQ-21

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically Testable
- **Complexity**: Complex
- **Rationale**: Forward chaining involves testing multiple linked resources through their references, requiring systematic verification across different resource types and their search parameters.

### Prerequisites
1. Server must be operational and accessible
2. Test dataset must include:
   - Multiple interlinked resources (e.g., Patient->Encounter->Observation)
   - Sufficient depth of chaining (at least 2-3 levels)
   - Resources must have valid references between them

## 3. Test Implementation Strategy

### Required Test Data
1. Primary Test Dataset:
   ```
   Patient (id: test-patient-1)
     └── Encounter (id: test-encounter-1)
          └── Observation (id: test-observation-1)
   ```
2. Additional resources with similar chaining patterns for edge cases

### Test Scenarios

#### Basic Forward Chaining
1. Single-level chain:
   ```
   GET [base]/Observation?subject:Patient.name=John
   ```
2. Two-level chain:
   ```
   GET [base]/Observation?encounter:Encounter.subject:Patient.name=John
   ```

#### Advanced Scenarios
1. Multiple parameter chains:
   ```
   GET [base]/Observation?encounter:Encounter.type=emergency&subject:Patient.gender=male
   ```
2. Chain with date parameters:
   ```
   GET [base]/Observation?encounter:Encounter.date=2023-01-01
   ```

### Validation Criteria

#### Success Criteria
1. Server returns HTTP 200 OK for valid chain queries
2. Returned resources match the chaining criteria
3. Results are consistent with direct resource queries
4. Search results include proper bundling and correct count
5. Search maintains referential integrity

#### Error Handling
1. Server returns appropriate error codes for:
   - Invalid chain parameters (400 Bad Request)
   - Non-existent resources in chain (404 Not Found)
   - Unsupported chain parameters (400 Bad Request)

### Assertions
1. All resources in chain path exist
2. Forward references resolve correctly
3. Search results match expected resource counts
4. Response structure follows FHIR specification
5. Performance meets acceptable thresholds

### Test Steps
1. Setup test data
2. Execute basic chain queries
3. Verify results match expected resources
4. Test error conditions
5. Validate response formats
6. Check performance metrics
7. Document results

### Implementation Notes
- Test implementation should be automated
- Include error recovery mechanisms
- Log all responses for analysis
- Consider pagination impacts
- Document any chain limitations

## 4. Additional Considerations

### Performance Impacts
- Monitor response times for deep chains
- Consider timeout settings
- Test with varying result set sizes

### Security Considerations
- Verify chain queries respect resource-level security
- Test with different user permissions
- Ensure sensitive data is properly filtered

### Documentation Requirements
- Document supported chain depths
- List any chain restrictions
- Provide examples of valid chain queries
- Include error response examples

This test specification provides a comprehensive framework for verifying forward chaining support, ensuring both basic functionality and edge cases are covered while maintaining security and performance considerations.

---

<a id='req-22'></a>

### REQ-22: Reverse chaining support

**Description**: "Support reverse chaining on all search parameters that specify the 'chain' property."

**Actor**: Server

**Conformance**: SHALL

# Test Specification for REQ-22: Reverse Chaining Support

## 1. Requirement ID
REQ-22

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically Testable
- **Complexity**: Complex
- **Rationale**: Reverse chaining is a specific FHIR search functionality that can be systematically tested through API calls, but requires multiple interconnected resources and comprehensive test scenarios.

### Prerequisites
1. FHIR server implementation with search capabilities
2. Test dataset containing multiple interconnected resources with established references
3. Documentation of all search parameters that specify the 'chain' property for the implemented resources
4. Server must support at least two different resource types with referential relationships

## 3. Test Implementation Strategy

### Required Test Data Setup
1. Create a network of related resources, for example:
   - Patient resources
   - Observation resources referencing Patients
   - Condition resources referencing Patients
   - Practitioner resources
   - Encounter resources linking Patients and Practitioners

### Test Scenarios

#### Basic Reverse Chaining Test
1. Test reverse chaining from Patient to Observation:
```
GET [base]/Observation?_has:Patient:subject:name=Smith
```
Expected: Returns Observations where the referenced Patient has name "Smith"

#### Multiple Resource Type Test
1. Test reverse chaining across multiple resource types:
```
GET [base]/Patient?_has:Observation:subject:code=8867-4
GET [base]/Patient?_has:Condition:subject:code=J45.901
```
Expected: Returns Patients who have Observations/Conditions matching the specified codes

#### Multiple Level Reverse Chaining Test
1. Test nested reverse chaining:
```
GET [base]/Practitioner?_has:Encounter:practitioner:_has:Observation:encounter:code=8867-4
```
Expected: Returns Practitioners who are referenced in Encounters that have Observations with the specified code

### Validation Criteria

1. Response Format:
   - Server returns valid FHIR Bundle
   - Bundle contains appropriate resource types
   - HTTP status code 200 for successful searches

2. Content Validation:
   - Returned resources match the reverse chain criteria
   - All required elements are present
   - References are valid and resolvable

3. Error Handling:
   - Server returns appropriate error responses for invalid reverse chain syntax
   - Server handles non-existent references appropriately

### Test Steps

1. **Setup Phase**
   - Deploy test dataset
   - Verify resource accessibility

2. **Execution Phase**
   - Execute basic reverse chaining tests
   - Execute multiple resource type tests
   - Execute multiple level reverse chaining tests
   - Document responses

3. **Validation Phase**
   - Verify response format
   - Validate content
   - Check error handling
   - Compare results against expected outcomes

### Pass/Fail Criteria

Test passes if:
1. All reverse chain queries return HTTP 200
2. Returned resources match the specified criteria
3. Error cases return appropriate status codes
4. All validation criteria are met

Test fails if:
1. Server doesn't support reverse chaining syntax
2. Queries return incorrect resources
3. Server returns unexpected errors
4. Validation criteria are not met

### Limitations and Assumptions
1. Server implements FHIR R4 or later
2. Server supports the resource types being tested
3. Test data contains sufficient variety of resources and relationships
4. All referenced search parameters are properly implemented

---

<a id='req-23'></a>

### REQ-23: XML format support

**Description**: "Support xml source formats for all Plan-Net interactions."

**Actor**: Server

**Conformance**: SHOULD

# Test Specification for REQ-23: XML Format Support

## 1. Requirement ID
REQ-23: XML Format Support for Plan-Net Interactions

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically Testable
- **Justification**: The requirement can be tested through automated HTTP requests with appropriate Accept/Content-Type headers and validation of responses

### Complexity
- **Level**: Moderate
- **Rationale**: While the concept is straightforward, comprehensive testing requires checking multiple interaction types and resources

### Prerequisites
- FHIR server implementing Plan-Net IG
- Test client capable of making HTTP requests with specified headers
- Sample data for each resource type supported by the server
- Valid test credentials if authentication is required

## 3. Test Implementation Strategy

### Required Inputs
- List of all supported Plan-Net resources
- Sample instances of each resource type in XML format
- Valid search parameters for each resource type

### Required FHIR Operations
For each supported resource type, test:
1. READ operations
2. SEARCH operations
3. CREATE operations (if supported)
4. UPDATE operations (if supported)
5. DELETE operations (if supported)

### Test Cases

#### TC1: Read Operation XML Support
```
1. Send GET request to [base]/[resource-type]/[id]
   Headers: Accept: application/fhir+xml
2. Verify response:
   - Status code 200
   - Content-Type header includes application/fhir+xml
   - Valid FHIR XML format
```

#### TC2: Search Operation XML Support
```
1. Send GET request to [base]/[resource-type]?[search-parameters]
   Headers: Accept: application/fhir+xml
2. Verify response:
   - Status code 200
   - Content-Type header includes application/fhir+xml
   - Bundle resource in XML format
   - Valid FHIR XML format
```

#### TC3: Create Operation XML Support
```
1. Send POST request to [base]/[resource-type]
   Headers: 
   - Content-Type: application/fhir+xml
   - Accept: application/fhir+xml
   Body: Valid resource in XML format
2. Verify response:
   - Status code 201
   - Content-Type header includes application/fhir+xml
   - Created resource returned in XML format
```

### Validation Criteria

1. HTTP Response Validation:
   - Correct status codes returned
   - Content-Type headers properly set
   - Accept headers honored

2. Content Validation:
   - Well-formed XML
   - Valid against FHIR schema
   - Correct resource types returned
   - Correct content returned

3. Error Handling:
   - Appropriate error responses in XML format
   - OperationOutcome resources returned in XML when errors occur

### Test Data Requirements

1. Sample Resources:
   - Healthcare Service
   - Organization
   - Location
   - Practitioner
   - PractitionerRole
   - Network
   - Endpoint
   - InsurancePlan

2. Invalid Test Cases:
   - Malformed XML
   - Invalid resource IDs
   - Invalid search parameters

### Notes
- The SHOULD conformance level indicates this is recommended but not mandatory
- Implementation should test both successful and error scenarios
- Consider testing with various XML versions and character encodings
- Include edge cases such as large resources and special characters

---

<a id='req-24'></a>

### REQ-24: Rejection of unauthorized requests

**Description**: "A server SHALL reject any unauthorized requests by returning an HTTP 401 unauthorized response code."

**Actor**: Server

**Conformance**: SHALL

# Test Specification for REQ-24

## 1. Requirement ID
REQ-24: Rejection of unauthorized requests

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically Testable
- **Justification**: The requirement specifies a clear expected behavior (HTTP 401 response) for a specific condition (unauthorized requests), which can be tested programmatically.

### Complexity
- **Level**: Moderate
- **Rationale**: While the response verification is simple, proper testing requires multiple test scenarios and authentication configurations.

### Prerequisites
- Server must be configured with authentication enabled
- Valid and invalid authentication credentials must be available for testing
- Server must be running and accessible
- Authentication mechanism (e.g., OAuth2, Basic Auth) must be documented and configured

## 3. Test Implementation Strategy

### Required Inputs
1. Valid authentication credentials (for control test)
2. Invalid authentication credentials
3. No authentication credentials
4. Expired authentication tokens (if using token-based auth)

### Test Scenarios

#### Scenario 1: No Authentication
```
Test Steps:
1. Send a GET request to a protected endpoint without any authentication
Expected Result: HTTP 401 response
```

#### Scenario 2: Invalid Authentication
```
Test Steps:
1. Send a GET request with invalid credentials
Expected Result: HTTP 401 response
```

#### Scenario 3: Expired Token
```
Test Steps:
1. Obtain a valid token
2. Wait for token expiration
3. Send request with expired token
Expected Result: HTTP 401 response
```

#### Scenario 4: Control Test
```
Test Steps:
1. Send request with valid authentication
Expected Result: HTTP 2XX response (NOT 401)
```

### Required FHIR Operations
- GET /Patient (or any available endpoint from capability statement)
- POST /Patient (if supported)
- PUT /Patient (if supported)
- DELETE /Patient (if supported)

### Validation Criteria

#### Response Validation
1. HTTP Status Code must be 401 for unauthorized requests
2. Response headers should include:
   - WWW-Authenticate header indicating the authentication scheme required
3. Response body should contain:
   - OperationOutcome resource (if supported)
   - Clear error message indicating authentication failure

#### Assert Statements
```
- Assert response.status_code equals 401
- Assert response.headers contains "WWW-Authenticate"
- Assert response.body contains authentication error message
- Assert control test does NOT return 401
```

### Test Data Requirements
1. Sample FHIR resources for testing different operations
2. Valid authentication credentials for control tests
3. Invalid/expired authentication tokens
4. Different authentication schemes if multiple are supported

### Edge Cases to Consider
1. Malformed authentication headers
2. Mixed case in authentication credentials
3. Partially valid credentials
4. Multiple authentication methods in same request

## Notes
- Tests should be executed for all supported FHIR operations
- Tests should verify that 401 is returned consistently across all protected endpoints
- Implementation should include proper cleanup of any test data
- Consider rate limiting impact on tests
- Document any authentication-specific configuration required for test execution

---

<a id='req-25'></a>

### REQ-25: Support for read interaction

**Description**: "For each resource type and profile, a Plan Net server SHALL support the read interaction."

**Actor**: Server

**Conformance**: SHALL

# Test Specification for REQ-25

## 1. Requirement ID
REQ-25: Support for read interaction

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically Testable
- This requirement can be systematically tested through automated API calls and validation

### Complexity
- **Level**: Moderate
- While the individual read operation is simple, testing across all resource types and profiles increases complexity

### Prerequisites
- Server must be operational and accessible
- Test data for each resource type and profile must be pre-populated
- Known valid resource IDs for each resource type
- List of all supported resource types and profiles from the Implementation Guide

## 3. Test Implementation Strategy

### Required Inputs
- Collection of valid resource IDs for each supported resource type
- List of all resource types defined in the IG
- List of all profiles defined in the IG

### Required FHIR Operations
For each resource type and profile:
```
GET [base]/[ResourceType]/[id]
```

### Test Cases

#### Base Test Cases
1. **Positive Tests**
   - Execute read operation for each resource type with known valid IDs
   - Verify successful retrieval and correct resource type returned
   
2. **Negative Tests**
   - Test with non-existent resource IDs (expect 404)
   - Test with invalid resource types (expect 404)
   - Test with malformed IDs (expect 400)

### Validation Criteria

#### Success Criteria
1. Server returns HTTP 200 OK for valid read requests
2. Response contains valid FHIR resource matching requested type
3. Resource conforms to applicable profile constraints
4. Content-Type header indicates "application/fhir+json" or "application/fhir+xml"

#### Error Handling Criteria
1. Server returns appropriate error status codes:
   - 404 for non-existent resources
   - 400 for invalid requests
   - 401 for unauthorized requests (if applicable)

### Test Script Pseudo-code
```python
def test_read_interaction():
    # Get list of resource types and profiles
    resource_types = get_supported_resource_types()
    
    for resource_type in resource_types:
        # Get test data ID for resource type
        test_id = get_valid_resource_id(resource_type)
        
        # Test valid read
        response = execute_read(resource_type, test_id)
        assert response.status_code == 200
        assert response.resource_type == resource_type
        assert is_valid_fhir_resource(response.body)
        
        # Test non-existent ID
        response = execute_read(resource_type, "non-existent-id")
        assert response.status_code == 404
```

### Additional Considerations
1. Test cases should include both JSON and XML formats if supported
2. Consider testing with various authorization scenarios if applicable
3. Monitor response times for performance implications
4. Verify proper handling of version-specific reads if supported
5. Test proper handling of _format parameter if supported

---

<a id='req-26'></a>

### REQ-26: Support for vread interaction

**Description**: "For each resource type and profile, a Plan Net server SHOULD support the vread interaction."

**Actor**: Server

**Conformance**: SHOULD

# Test Specification for REQ-26

## 1. Requirement ID
REQ-26: Support for vread interaction

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically Testable
- **Rationale**: The vread interaction is a standard FHIR operation that can be systematically tested through API calls

### Complexity
- **Level**: Moderate
- **Rationale**: While the operation itself is straightforward, testing needs to cover multiple resource types and versions

### Prerequisites
- Server must be operational and accessible
- Test data must exist for multiple resource types
- Multiple versions of resources must exist in the system
- Server must maintain version history for resources

## 3. Test Implementation Strategy

### Required Inputs
1. List of resource types supported by the server
2. Test resources with multiple versions:
   ```json
   {
     "resourceType": "Organization",
     "id": "test-org",
     "name": "Test Organization",
     // ... other required fields
   }
   ```

### Required FHIR Operations
1. PUT/POST operations to create and update resources
2. GET operation to retrieve current version
3. vread operation to retrieve specific versions:
   - `GET [base]/[ResourceType]/[id]/_history/[versionId]`

### Test Approach
1. **Setup Phase**
   - Create a new resource instance
   - Update the resource at least twice to create multiple versions
   - Record the version IDs returned in the response headers

2. **Test Phase**
   For each supported resource type:
   1. Attempt to retrieve specific versions using vread
   2. Verify responses for both existing and non-existing versions
   3. Test boundary conditions (first version, latest version)

### Validation Criteria

#### Success Criteria
1. Server returns HTTP 200 OK for valid vread requests
2. Response contains:
   - Correct resource content for the specified version
   - Correct meta.versionId matching the requested version
   - Correct Content-Location header

#### Error Validation
1. Server returns appropriate error codes:
   - 404 Not Found for non-existent resources
   - 404 Not Found for non-existent versions
   - 400 Bad Request for invalid version formats

### Test Cases

1. **Basic Version Retrieval**
   ```
   GET [base]/Organization/test-org/_history/1
   Expected: 200 OK with first version of resource
   ```

2. **Latest Version Retrieval**
   ```
   GET [base]/Organization/test-org/_history/[latest-version]
   Expected: 200 OK with latest version of resource
   ```

3. **Non-existent Version**
   ```
   GET [base]/Organization/test-org/_history/999
   Expected: 404 Not Found
   ```

4. **Invalid Version Format**
   ```
   GET [base]/Organization/test-org/_history/invalid
   Expected: 400 Bad Request
   ```

### Test Data Requirements
- Minimum of 3 different resource types
- Each resource should have at least 3 versions
- Include both active and inactive resources

### Notes
- Since this is a SHOULD requirement, servers that don't support vread should document this limitation
- Test implementation should be parameterized to run against all supported resource types
- Consider performance implications when testing with large resources or many versions

---

<a id='req-27'></a>

### REQ-27: Support for _includes

**Description**: "[For each resource] A Server SHALL be capable of supporting the following _includes [list]."

**Actor**: Server

**Conformance**: SHALL

# Test Specification for REQ-27: Support for _includes

## 1. Requirement ID
REQ-27

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically Testable
- **Rationale**: The _include parameter support can be systematically tested through API calls and validation of responses

### Complexity
- **Level**: Moderate
- **Reasoning**: While the basic mechanism is straightforward, comprehensive testing requires multiple scenarios across different resources and include paths

### Prerequisites
- Server must be operational and accessible
- Test data must exist in the system containing resources with valid references
- List of supported _include paths for each resource type must be documented
- Server must implement RESTful API endpoints for the resources being tested

## 3. Test Implementation Strategy

### Required Inputs
- List of resource types to test
- For each resource type:
  - Valid _include paths
  - Sample resources with existing references matching the include paths
  - Expected included resources in responses

### Required FHIR Operations
1. GET requests for each resource type with:
   - No _include parameter (baseline)
   - Single _include parameter
   - Multiple _include parameters
   - Invalid _include parameter (negative test)
   ```
   GET [base]/[ResourceType]?_include=[path]
   GET [base]/[ResourceType]?_include=[path1]&_include=[path2]
   ```

### Validation Criteria

#### Positive Tests
1. For each supported resource type:
   - Response contains the primary resources
   - Response contains all requested included resources
   - Included resources match the specified _include paths
   - Bundle.entry.search.mode = "include" for included resources
   - HTTP 200 OK status code

2. Multiple includes:
   - Response correctly contains all requested included resources
   - No duplicate resources in response

#### Negative Tests
1. Invalid _include parameter:
   - Server returns appropriate error (400 Bad Request)
   - Clear error message indicating invalid _include

### Test Cases Template
```
For each Resource Type:

1. Basic Include Test
   Request: GET [base]/[ResourceType]?_include=[valid-path]
   Expected:
   - Status: 200
   - Contains primary resources
   - Contains included resources
   - Correct search.mode values

2. Multiple Include Test
   Request: GET [base]/[ResourceType]?_include=[path1]&_include=[path2]
   Expected:
   - Status: 200
   - Contains all specified included resources
   - No duplicates

3. Invalid Include Test
   Request: GET [base]/[ResourceType]?_include=invalid-path
   Expected:
   - Status: 400
   - Clear error message
```

### Documentation Requirements
- List of tested resource types
- List of tested _include paths
- Test results for each combination
- Any failed assertions or unexpected behaviors
- Performance metrics (optional)

## Notes
- Consider rate limiting and server load when testing multiple includes
- Document any resource-specific behaviors or limitations
- Consider testing edge cases like:
  - Maximum number of includes
  - Deeply nested includes
  - Resources with multiple valid references of the same type

---

<a id='req-28'></a>

### REQ-28: Support for _revincludes

**Description**: "[For each resource] A Server SHALL be capable of supporting the following _revincludes: [list]."

**Actor**: Server

**Conformance**: SHALL

# Test Specification for REQ-28

## 1. Requirement ID
REQ-28: Support for _revincludes

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically Testable
- **Rationale**: The _revinclude parameter support can be systematically tested through API calls and response validation

### Complexity
- **Level**: Moderate 
- **Rationale**: Testing requires multiple API calls across different resource types and verification of reverse references

### Prerequisites
1. Test server must be operational and accessible
2. Test data must include:
   - Multiple resource instances with references between them
   - At least 2-3 different resource types that have relationships
   - Resources that have both existing and non-existing reverse references

## 3. Test Implementation Strategy

### Required Inputs
1. Base FHIR server URL
2. List of resource types to test
3. Sample resources with known reference relationships
4. Expected _revinclude parameters for each resource type

### Required FHIR Operations
1. GET [base]/[resourceType]?_revinclude=[referencing-resource]:[search-parameter]
2. Example: GET [base]/Patient?_revinclude=Observation:subject

### Test Cases

#### Test Case 1: Basic _revinclude Support
1. **Purpose**: Verify basic _revinclude functionality
2. **Steps**:
   - Execute search with _revinclude parameter
   - Verify response structure
   - Validate included resources match the _revinclude specification

#### Test Case 2: Multiple _revincludes
1. **Purpose**: Verify support for multiple _revinclude parameters
2. **Steps**:
   - Execute search with multiple _revinclude parameters
   - Verify all specified reverse references are included
   - Validate response bundle structure

#### Test Case 3: Non-existent References
1. **Purpose**: Verify proper handling of _revinclude when no reverse references exist
2. **Steps**:
   - Execute search with _revinclude for known non-existent references
   - Verify appropriate empty results
   - Validate response structure

### Validation Criteria

#### Response Structure Validation
- Response must be a valid FHIR Bundle
- Bundle must contain both primary resources and included resources
- Included resources must match the _revinclude specification

#### Content Validation
1. All reverse references specified in _revinclude must be present
2. Referenced resources must be valid FHIR resources
3. Reference integrity must be maintained

#### Error Handling
1. Invalid _revinclude parameters should return appropriate error responses
2. Server should handle multiple _revinclude parameters correctly

### Test Data Requirements
1. Minimum Dataset:
   - Primary resource instances (e.g., Patient)
   - Referenced resource instances (e.g., Observation)
   - Known reference relationships between resources

2. Edge Cases:
   - Resources with multiple reverse references
   - Resources with no reverse references
   - Invalid reference scenarios

### Expected Results
1. Successful responses should:
   - Return HTTP 200 OK
   - Include all specified reverse references
   - Maintain proper Bundle structure
   - Include valid FHIR resources

2. Error responses should:
   - Return appropriate HTTP status codes
   - Include OperationOutcome with clear error messages
   - Handle invalid parameters appropriately

---

<a id='req-29'></a>

### REQ-29: Network profile NPI handling

**Description**: "The NPI and CLIA identifier types, which are Must-Support, are clearly intended for provider organizations only and are not expected to be populated for other organization types."

**Actor**: Server

**Conformance**: None (Clarification)

# Test Specification for REQ-29

## 1. Requirement ID
REQ-29: Network profile NPI handling

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Semi-Automatically Testable
- **Rationale**: While presence/absence of NPI/CLIA can be automatically verified, determining organization type requires business context validation

### Complexity
- **Moderate**
- **Rationale**: Requires multiple test cases across different organization types and validation of conditional requirements

### Prerequisites
- Test environment with FHIR server implementation
- Sample Organization resources representing:
  - Provider organizations (should have NPI/CLIA)
  - Non-provider organizations (should not have NPI/CLIA)
- Access to server endpoints supporting Organization resource operations

## 3. Test Implementation Strategy

### Required Inputs
- **FHIR Resources**:
  1. Organization resources with provider type characteristics
  2. Organization resources with non-provider type characteristics
  3. Sample valid NPI numbers
  4. Sample valid CLIA numbers

### Test Cases

#### Test Case 1: Provider Organization Validation
```
Given: An Organization resource representing a provider organization
When: The resource is retrieved
Then: The identifier array should contain valid NPI and/or CLIA identifiers
```

#### Test Case 2: Non-Provider Organization Validation
```
Given: An Organization resource representing a non-provider organization
When: The resource is retrieved
Then: The identifier array should not contain NPI or CLIA identifiers
```

### Required FHIR Operations
- `GET [base]/Organization/{id}`
- `GET [base]/Organization?identifier=[system]|[value]`

### Validation Criteria

#### For Provider Organizations:
1. Verify identifier array contains at least one of:
   - NPI identifier with system "http://hl7.org/fhir/sid/us-npi"
   - CLIA identifier with system "urn:oid:2.16.840.1.113883.4.7"
2. Validate NPI format (10 digits)
3. Validate CLIA format (if present)

#### For Non-Provider Organizations:
1. Verify identifier array does not contain:
   - NPI identifiers
   - CLIA identifiers

### Test Data Requirements
```json
{
  "resourceType": "Organization",
  "id": "provider-org-example",
  "identifier": [
    {
      "system": "http://hl7.org/fhir/sid/us-npi",
      "value": "1234567890"
    }
  ],
  "type": [
    {
      "coding": [
        {
          "system": "http://terminology.hl7.org/CodeSystem/organization-type",
          "code": "prov"
        }
      ]
    }
  ]
}
```

### Implementation Notes
1. Test implementation should include logic to determine organization type
2. Consider edge cases such as:
   - Organizations transitioning between provider/non-provider status
   - Organizations with multiple roles
   - Invalid NPI/CLIA format validation
3. Document any assumptions about how organization type is determined

### Success Criteria
- All provider organizations must have valid NPI and/or CLIA identifiers
- No non-provider organizations should have NPI or CLIA identifiers
- All identifier formats must be valid when present

---

<a id='req-30'></a>

### REQ-30: lastUpdate timestamp requirement

**Description**: "Each profile in this guide requires that the lastUpdate timestamp be provided as part of the profile's data content."

**Actor**: Server

**Conformance**: None (Requirement)

# Test Specification for REQ-30

## 1. Requirement ID
REQ-30: lastUpdate timestamp requirement

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically testable
- **Rationale**: The presence and format of lastUpdate timestamp can be programmatically verified across all profiles

### Complexity
- **Level**: Simple
- **Rationale**: Straightforward verification of a single data element across resources

### Prerequisites
- Access to FHIR server endpoint
- List of all applicable profiles defined in the Implementation Guide
- Test data containing resources conforming to the defined profiles
- Authentication credentials if required

## 3. Test Implementation Strategy

### Required Inputs
- Collection of FHIR resources conforming to each profile defined in the IG
- List of all profile URLs defined in the IG

### Required FHIR Operations
1. READ operations to retrieve resources for each profile type
2. SEARCH operations to retrieve collections of resources for each profile type

### Test Cases

#### TC1: Verify lastUpdate Presence
1. For each profile defined in the IG:
   - Retrieve sample resources conforming to the profile
   - Verify lastUpdate element exists
   - Verify lastUpdate is not null/empty

#### TC2: Verify lastUpdate Format
1. For each retrieved resource:
   - Verify lastUpdate contains valid timestamp
   - Verify timestamp follows ISO 8601 format
   - Verify timezone information is included

#### TC3: Verify lastUpdate Business Logic
1. For each retrieved resource:
   - Verify lastUpdate is not a future date
   - Verify lastUpdate is not before resource creation date

### Validation Criteria

#### Pass Criteria
- All resources of all profiles contain lastUpdate element
- All lastUpdate timestamps are:
  - Present
  - Valid ISO 8601 format
  - Include timezone information
  - Not in future
  - Not before resource creation date

#### Fail Criteria
- Any resource missing lastUpdate element
- Invalid timestamp format
- Future dates
- Dates before resource creation
- Empty/null values

### Test Data Requirements
```json
{
  "resourceType": "Patient",
  "id": "test-patient",
  "meta": {
    "lastUpdated": "2023-11-14T10:30:00Z"
  }
  // ... other required elements
}
```

### Error Scenarios to Test
1. Missing lastUpdate element
2. Invalid date format
3. Future date
4. Date before resource creation
5. Null value
6. Invalid timezone format

### Test Limitations and Assumptions
- Test assumes all profiles are documented and accessible
- Test assumes server supports READ and SEARCH operations
- Test cannot verify if lastUpdate reflects actual last modification time

---

<a id='req-32'></a>

### REQ-32: General Search for Pharmacy

**Description**: "The Plan-Net design is based around the following types of searches: General Search - Example: Pharmacy - Focal Resource and Field: HealthcareService.category, HealthcareService.specialty - Qualifications of Search: Location, network."

**Actor**: Server

**Conformance**: None (Design requirement)

# Test Specification for REQ-32

## 1. Requirement ID
REQ-32: General Search for Pharmacy

## 2. Requirement Analysis

### Testability Assessment
Automatically testable through a series of API calls and response validations

### Complexity
Moderate - Requires multiple search combinations and validation of search result relationships

### Prerequisites
- Test server must be operational and configured with FHIR R4
- Test data must include:
  - HealthcareService resources representing pharmacy services
  - Associated Location resources
  - Network affiliation data
  - Valid category and specialty codes for pharmacy services

## 3. Test Implementation Strategy

### Required Test Data
**HealthcareService Resources:**
- Minimum 3 pharmacy services with different characteristics:
  - Different categories (retail, specialty, etc.)
  - Different specialties (compounding, mail order, etc.)
  - Different locations
  - Different network affiliations

**Location Resources:**
- Corresponding locations for each pharmacy service
- Mix of different address information
- Network affiliations

### Required FHIR Operations
Based on Capability Statement, the following search operations will be used:

1. HealthcareService Search:
```
GET [base]/HealthcareService?service-category={pharmacy-code}&specialty={specialty-code}
GET [base]/HealthcareService?location={location-reference}
```

2. Location-based filtering:
```
GET [base]/Location?address-city={city}&address-state={state}
GET [base]/Location?type={pharmacy-type}
```

### Test Scenarios

#### Scenario 1: Basic Pharmacy Search
1. Search for pharmacy services by category:
```
GET [base]/HealthcareService?service-category=pharmacy
```
**Validation:**
- Response contains only pharmacy services
- Bundle.total > 0
- Each entry has correct category coding

#### Scenario 2: Specialty Pharmacy Search
1. Search for specialty pharmacy services:
```
GET [base]/HealthcareService?service-category=pharmacy&specialty=specialty
```
**Validation:**
- Results filtered to specialty pharmacies
- Correct specialty codes present in results

#### Scenario 3: Location-Based Pharmacy Search
1. First get locations in specific area:
```
GET [base]/Location?address-city=[city]&address-state=[state]
```
2. Then search for pharmacy services at those locations:
```
GET [base]/HealthcareService?service-category=pharmacy&location=[location-references]
```
**Validation:**
- Results only include pharmacies in specified geographic area
- Location references are valid
- Address information matches search criteria

### Validation Criteria

For all scenarios, verify:
1. Response Status Code = 200
2. Valid FHIR Bundle returned
3. Resources conform to US Core profiles if applicable
4. Search parameters work as specified:
   - category filters work correctly
   - specialty filters work correctly
   - location-based filtering works correctly
5. Required elements present in responses:
   - HealthcareService.category
   - HealthcareService.specialty (when applicable)
   - HealthcareService.location
   - Location.address
6. Network affiliations are correctly represented
7. Reference integrity between HealthcareService and Location resources

### Edge Cases to Test
1. Search with non-existent specialty codes
2. Search with invalid location references
3. Search with partial address information
4. Search combining multiple criteria
5. Search with pagination parameters
6. Search with _include parameters to include referenced resources

### Test Data Requirements
Provide specific test data examples including:
1. Valid pharmacy category codes
2. Valid specialty codes
3. Location references
4. Network affiliation codes
5. Address information for geographic searches

---

<a id='req-33'></a>

### REQ-33: Provider search by name

**Description**: "The Plan-Net design is based around the following types of searches: Provider by Name - Example: Joe Smith - Focal Resource and Field: Practitioner.name - Qualifications of Search: Location, network, specialty, role/privileges."

**Actor**: Server

**Conformance**: None (Design requirement)

# Test Specification for REQ-33: Provider Search by Name

## 1. Requirement ID
REQ-33

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically Testable
- **Rationale**: The requirement involves concrete search operations using defined search parameters that can be verified programmatically.

### Complexity
- **Level**: Moderate
- **Rationale**: While the basic name search is straightforward, testing combinations with qualifications (location, network, specialty, role/privileges) increases complexity.

### Prerequisites
1. FHIR server implementing Plan-Net IG
2. Test dataset containing:
   - Multiple Practitioner resources with various name combinations
   - Associated Location resources
   - PractitionerRole resources linking practitioners to locations and specialties

## 3. Test Implementation Strategy

### Required Test Data
```json
{
  "resourceType": "Practitioner",
  "id": "test-practitioner-1",
  "name": [{
    "family": "Smith",
    "given": ["Joe"]
  }]
}
// Additional test practitioners with variations of names
```

### Required FHIR Operations

1. Basic Name Search Tests:
```
GET [base]/Practitioner?name=Joe+Smith
GET [base]/Practitioner?family=Smith
GET [base]/Practitioner?given=Joe
```

2. Combined Search Tests:
```
GET [base]/Practitioner?name=Joe+Smith&_include=Practitioner:location
GET [base]/Practitioner?name=Joe+Smith&_include=Practitioner:role
```

### Test Cases

#### TC1: Basic Name Search
1. **Description**: Search for practitioner by full name
2. **Input**: `GET [base]/Practitioner?name=Joe+Smith`
3. **Expected Output**: 
   - HTTP 200 OK
   - Bundle containing matching Practitioner resources
   - Exact and partial matches should be returned

#### TC2: Family Name Search
1. **Description**: Search for practitioner by family name
2. **Input**: `GET [base]/Practitioner?family=Smith`
3. **Expected Output**: 
   - HTTP 200 OK
   - Bundle containing all practitioners with family name "Smith"

#### TC3: Given Name Search
1. **Description**: Search for practitioner by given name
2. **Input**: `GET [base]/Practitioner?given=Joe`
3. **Expected Output**: 
   - HTTP 200 OK
   - Bundle containing all practitioners with given name "Joe"

### Validation Criteria

1. **Response Format**:
   - Verify HTTP status code is 200
   - Verify response is a valid FHIR Bundle
   - Verify Bundle.type is "searchset"

2. **Search Results**:
   - Verify returned practitioners match the search criteria
   - Verify partial matches are included when appropriate
   - Verify case-insensitive matching

3. **Error Handling**:
   - Verify appropriate error responses for invalid search parameters
   - Verify handling of special characters in names

4. **Performance**:
   - Response time should be within acceptable limits (e.g., < 2 seconds)

### Test Data Requirements

1. **Minimum Test Dataset**:
   - At least 5 Practitioner resources with various name combinations
   - Include exact matches, partial matches, and non-matches
   - Include special characters and multi-part names
   - Include associated Location and PractitionerRole resources

2. **Edge Cases**:
   - Names with special characters
   - Very long names
   - Names with multiple parts
   - Empty name fields
   - Multiple given names

### Notes
- The Capability Statement confirms support for all required search parameters (name, family, given)
- Implementation should follow FHIR search parameter rules for string matching
- Consider implementing fuzzy matching for names if supported by the server
- Test cases should include verification of search parameter modifiers if supported

---

<a id='req-34'></a>

### REQ-34: Organization search by name

**Description**: "The Plan-Net design is based around the following types of searches: Organization by Name - Example: Montgomery Cardiology or CVS - Focal Resource and Field: Organization.name - Qualifications of Search: Location, network, specialty."

**Actor**: Server

**Conformance**: None (Design requirement)

# Test Specification for REQ-34: Organization Search by Name

## 1. Requirement ID
REQ-34

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically Testable
- **Rationale**: The requirement specifies a concrete search functionality that can be tested through API calls with verifiable results.

### Complexity
- **Level**: Moderate
- **Rationale**: While the basic name search is straightforward, the requirement involves testing multiple scenarios including combinations with location, network, and specialty qualifications.

### Prerequisites
- Server must be operational and accessible
- Test data must include:
  - Multiple Organizations with different names
  - Organizations with similar/partial matching names
  - Organizations with associated locations
  - Organizations with network affiliations
  - Organizations with specialty designations

## 3. Test Implementation Strategy

### Required Test Data
```json
{
  "resourceType": "Organization",
  "name": "Montgomery Cardiology",
  "type": [
    {
      "coding": [
        {
          "system": "http://terminology.hl7.org/CodeSystem/organization-type",
          "code": "prov",
          "display": "Healthcare Provider"
        }
      ]
    }
  ]
}
```
(Similar test data needed for other test cases)

### Required FHIR Operations
1. Basic Name Search:
   ```
   GET [base]/Organization?name=[search term]
   ```
2. Combined Searches:
   ```
   GET [base]/Organization?name=[search term]&_include=Organization:location
   GET [base]/Organization?name=[search term]&type=[specialty code]
   ```

### Test Cases

#### TC1: Basic Name Search
- **Input**: Exact organization name
- **Operation**: `GET [base]/Organization?name=Montgomery Cardiology`
- **Expected Output**: 
  - HTTP 200 OK
  - Bundle containing matching Organization resource(s)
  - Validate returned organization has exact name match

#### TC2: Partial Name Search
- **Input**: Partial organization name
- **Operation**: `GET [base]/Organization?name=Montgomery`
- **Expected Output**: 
  - HTTP 200 OK
  - Bundle containing all organizations with "Montgomery" in their name

#### TC3: Case-Insensitive Search
- **Input**: Organization name with different case
- **Operation**: `GET [base]/Organization?name=montgomery cardiology`
- **Expected Output**: 
  - Should match same results as TC1

#### TC4: Combined Location Search
- **Input**: Organization name + location criteria
- **Operation**: `GET [base]/Organization?name=CVS&address-state=MA`
- **Expected Output**: 
  - Organizations matching name and location criteria

### Validation Criteria

1. Response Format Validation:
   - Response must be a valid FHIR Bundle
   - Each entry must be a valid Organization resource
   - Bundle must include total count of results

2. Search Behavior Validation:
   - Partial matches should work as expected
   - Case-insensitive matching should work
   - Empty results should return a valid empty Bundle
   - Large result sets should support pagination

3. Performance Validation:
   - Response time should be within acceptable limits (e.g., < 2 seconds)
   - Server should handle multiple concurrent search requests

### Error Scenarios to Test

1. Invalid Name Format:
   - **Input**: Special characters in name
   - **Expected**: Appropriate error response

2. Missing Required Parameters:
   - **Input**: Empty name parameter
   - **Expected**: Appropriate error response

3. Excessive Result Set:
   - **Input**: Very generic name that would match many organizations
   - **Expected**: Proper pagination implementation

## Notes
- All operations listed are supported in the Capability Statement
- The name search parameter is marked as SHALL support
- Implementation should consider FHIR search parameter rules for string matching
- Tests should verify both exact and partial matching scenarios

---

<a id='req-35'></a>

### REQ-35: Provider search by specialty

**Description**: "The Plan-Net design is based around the following types of searches: Provider by Specialty - Example: Cardiologist - Focal Resource and Field: PractitionerRole.specialty - Qualifications of Search: Location, network, name."

**Actor**: Server

**Conformance**: None (Design requirement)

# Test Specification for REQ-35: Provider Search by Specialty

## 1. Requirement ID
REQ-35: Provider search by specialty

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically Testable
- **Justification**: The requirement involves concrete search operations using defined search parameters that can be programmatically tested. The Capability Statement explicitly supports the required search parameters.

### Complexity
- **Level**: Moderate
- **Justification**: While the basic specialty search is straightforward, testing combinations with location and network parameters, plus validation of results, increases complexity.

### Prerequisites
- Server must be operational and configured with test data
- Test dataset must include:
  - PractitionerRole resources with various specialties
  - Associated Location resources
  - Associated Healthcare Network resources
  - Linked Practitioner resources with names

## 3. Test Implementation Strategy

### Required Test Data
```json
{
  "PractitionerRole": [
    {
      "specialty": "Cardiology",
      "location": ["Location/loc1"],
      "network": ["Network/net1"],
      "practitioner": "Practitioner/pract1"
    },
    {
      "specialty": "Cardiology",
      "location": ["Location/loc2"],
      "network": ["Network/net2"],
      "practitioner": "Practitioner/pract2"
    }
    // Additional test resources...
  ]
}
```

### Test Cases

#### Test Case 1: Basic Specialty Search
- **Operation**: `GET [base]/PractitionerRole?specialty=cardiology`
- **Validation**:
  - HTTP 200 OK response
  - Bundle contains only PractitionerRole resources
  - All returned resources have specialty = cardiology
  - Bundle.total reflects correct count

#### Test Case 2: Specialty + Location Search
- **Operation**: `GET [base]/PractitionerRole?specialty=cardiology&location=[location-reference]`
- **Validation**:
  - HTTP 200 OK response
  - All returned resources have specified specialty and location
  - Location references are valid

#### Test Case 3: Specialty + Network Search
- **Operation**: `GET [base]/PractitionerRole?specialty=cardiology&network=[network-reference]`
- **Validation**:
  - HTTP 200 OK response
  - All returned resources have specified specialty and network
  - Network references are valid

#### Test Case 4: Specialty + Practitioner Name Search
- **Operation**: `GET [base]/PractitionerRole?specialty=cardiology&practitioner.name=[name]`
- **Validation**:
  - HTTP 200 OK response
  - All returned resources have specified specialty
  - Referenced Practitioners match name criteria

### Validation Criteria

1. **Response Format**
   - Valid FHIR Bundle structure
   - Correct resourceType (Bundle)
   - Valid PractitionerRole resources in bundle entries

2. **Search Parameter Support**
   - Server must support all required search parameters:
     - specialty (token)
     - location (reference)
     - network (reference)
     - practitioner (reference)

3. **Data Validation**
   - All returned PractitionerRole resources must:
     - Have valid specialty codes
     - Contain valid references to Location, Network, and Practitioner resources
     - Match all search criteria specified in query

4. **Error Handling**
   - Server returns appropriate error codes for invalid searches
   - Server handles missing or invalid parameters appropriately

### Implementation Notes

1. Test implementation should use FHIR R4 compliant clients
2. Tests should include both positive and negative scenarios
3. Consider edge cases:
   - Empty result sets
   - Large result sets (pagination)
   - Case sensitivity in specialty codes
   - Multiple specialty codes
   - Invalid specialty codes

### Required FHIR Operations
All operations are supported according to the Capability Statement:
- GET operations on PractitionerRole
- Search parameters: specialty, location, network
- _include parameters for referenced resources

---

<a id='req-36'></a>

### REQ-36: Organization search by specialty

**Description**: "The Plan-Net design is based around the following types of searches: Organization by specialty - Example: Compounding Pharmacy - Focal Resource and Field: OrganizationAffiliation.specialty - Qualifications of Search: Location, network, name."

**Actor**: Server

**Conformance**: None (Design requirement)

# Test Specification: Organization Search by Specialty

## 1. Requirement ID
REQ-36

## 2. Requirement Analysis

### Testability Assessment
- Automatically testable
- Requires multiple related test cases to verify different search scenarios

### Complexity
Moderate - Requires testing multiple search parameters in combination and verifying relationships between resources

### Prerequisites
1. Test server must support OrganizationAffiliation resource with specialty search parameter
2. Test data must include:
   - Organizations with various specialties
   - OrganizationAffiliations linking organizations with specific specialties
   - Associated Location resources
   - Network affiliations
   - Organizations with names that can be searched

## 3. Test Implementation Strategy

### Required Resources
1. Organization resources representing healthcare facilities
2. OrganizationAffiliation resources with specialty codes
3. Location resources linked to Organizations
4. Network resources for testing network-based filtering

### Test Cases

#### Test Case 1: Basic Specialty Search
```
GET [base]/OrganizationAffiliation?specialty=pharmacy-compounding
```
**Validation Criteria:**
- Response contains only OrganizationAffiliations with compounding pharmacy specialty
- HTTP 200 OK response
- Bundle contains matching resources
- Each returned OrganizationAffiliation.specialty must contain the searched specialty code

#### Test Case 2: Specialty + Location Search
```
GET [base]/OrganizationAffiliation?specialty=pharmacy-compounding&location=[location-id]
```
**Validation Criteria:**
- Results filtered by both specialty and location
- All returned organizations must be associated with specified location
- Specialty validation same as Test Case 1

#### Test Case 3: Specialty + Network Search
```
GET [base]/OrganizationAffiliation?specialty=pharmacy-compounding&network=[network-id]
```
**Validation Criteria:**
- Results filtered by both specialty and network
- All returned organizations must be part of specified network
- Specialty validation same as Test Case 1

#### Test Case 4: Specialty + Organization Name Search
```
GET [base]/OrganizationAffiliation?specialty=pharmacy-compounding&participating-organization.name=[name]
```
**Validation Criteria:**
- Results filtered by both specialty and organization name
- Returned organizations must match name criteria
- Specialty validation same as Test Case 1

### Required FHIR Operations
All operations are supported per Capability Statement:
- OrganizationAffiliation search with specialty parameter (SHALL)
- OrganizationAffiliation search with location parameter (SHALL)
- OrganizationAffiliation search with network parameter (SHALL)
- Organization search with name parameter (SHALL)

### Error Test Cases
1. Invalid specialty code
```
GET [base]/OrganizationAffiliation?specialty=INVALID-CODE
```
**Validation Criteria:**
- Server should return appropriate error response
- HTTP 400 Bad Request or empty search results

2. Non-existent location reference
```
GET [base]/OrganizationAffiliation?specialty=pharmacy-compounding&location=Location/non-existent
```
**Validation Criteria:**
- Server should return appropriate error response or empty search results

### Additional Validation Criteria
1. Response Bundle Structure:
   - Must contain valid FHIR Bundle resource
   - Each entry must be a valid OrganizationAffiliation resource
   - Must include proper total count if supported

2. Resource Validation:
   - Each returned OrganizationAffiliation must have:
     - Valid specialty coding
     - Valid references to Organization resources
     - Valid references to Location resources when filtered by location
     - Valid references to Network resources when filtered by network

3. Search Parameter Validation:
   - Verify that search parameters are processed correctly in combination
   - Verify that partial matches work as expected for name searches
   - Verify that token searches for specialty codes work with system|code format

---

<a id='req-37'></a>

### REQ-37: Search for active practitioners and organizations

**Description**: "Sample query to search for currently active Practitioners (replace date in query with current date): http://davinci-plan-net-ri.logicahealth.org/fhir/PractitionerRole?_include=PractitionerRole:date=ge2021-10-25. Sample query to search for currently active Organizations (replace date in query with current date): http://davinci-plan-net-ri.logicahealth.org/fhir/OrganizationAffiliation?_include=OrganizationAffiliation:date=ge2021-10-25."

**Actor**: Server

**Conformance**: None (Implementation example)

# Test Specification for REQ-37

## 1. Requirement ID
REQ-37: Search for active practitioners and organizations

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically testable
- **Rationale**: The requirement involves specific FHIR search operations that can be automated and verified programmatically

### Complexity
- **Level**: Moderate
- **Rationale**: Involves multiple resource types and search parameters, but uses standard FHIR operations

### Prerequisites
1. Test server must be operational and accessible
2. Server must support PractitionerRole and OrganizationAffiliation resources
3. Test data must include:
   - Active PractitionerRole resources with various dates
   - Active OrganizationAffiliation resources with various dates
   - Associated Practitioner and Organization resources
   - Mix of active and inactive records

## 3. Test Implementation Strategy

### Required Test Data

#### Minimum Dataset:
1. PractitionerRole resources:
   - At least 2 active records with dates after test date
   - At least 1 inactive record
   - At least 1 active record with date before test date

2. OrganizationAffiliation resources:
   - At least 2 active records with dates after test date
   - At least 1 inactive record
   - At least 1 active record with date before test date

### Required FHIR Operations

1. PractitionerRole Search:
```
GET [base]/PractitionerRole?date=ge[test_date]&_include=PractitionerRole:practitioner&_include=PractitionerRole:organization
```

2. OrganizationAffiliation Search:
```
GET [base]/OrganizationAffiliation?date=ge[test_date]&_include=OrganizationAffiliation:primary-organization&_include=OrganizationAffiliation:participating-organization
```

### Test Cases

#### Test Case 1: PractitionerRole Active Search
1. **Setup**:
   - Set test_date to current date
   - Ensure test data is loaded

2. **Actions**:
   - Execute PractitionerRole search query
   - Record response

3. **Validation Criteria**:
   - HTTP response code is 200
   - Bundle resource returned
   - Only PractitionerRole resources with dates >= test_date included
   - Included Practitioner resources are present
   - Included Organization resources are present
   - Bundle.total matches expected count

#### Test Case 2: OrganizationAffiliation Active Search
1. **Setup**:
   - Set test_date to current date
   - Ensure test data is loaded

2. **Actions**:
   - Execute OrganizationAffiliation search query
   - Record response

3. **Validation Criteria**:
   - HTTP response code is 200
   - Bundle resource returned
   - Only OrganizationAffiliation resources with dates >= test_date included
   - Included Organization resources are present
   - Bundle.total matches expected count

### Error Cases to Test

1. Invalid Date Format:
   - Submit query with malformed date
   - Verify appropriate error response (400 Bad Request)

2. Future Date:
   - Submit query with future date
   - Verify empty or appropriate result set

### Test Scripts Structure

```python
def test_active_practitioner_search():
    # Setup
    test_date = get_current_date()
    
    # Execute
    response = execute_practitioner_search(test_date)
    
    # Validate
    assert response.status_code == 200
    bundle = parse_bundle(response)
    validate_practitioner_results(bundle, test_date)

def test_active_organization_search():
    # Similar structure for organization search
    pass
```

### Validation Functions

```python
def validate_practitioner_results(bundle, test_date):
    # Check bundle type
    assert bundle.type == 'searchset'
    
    # Validate each entry
    for entry in bundle.entry:
        if entry.resource.resourceType == 'PractitionerRole':
            assert entry.resource.date >= test_date
            
    # Validate includes
    assert_includes_present(bundle)
```

## Notes
- All operations must align with server's Capability Statement
- Test implementation should be parameterized to allow for different test dates
- Consider implementing pagination handling for large result sets
- Error handling should be robust and informative

---

<a id='req-38'></a>

### REQ-38: Network contact handling for departments

**Description**: "When the contact is a department name, rather than a human (e.g., patient help line), include a blank family and given name, and provide the department name in contact.name.text."

**Actor**: Server

**Conformance**: None (Implementation guidance)

# Test Specification for REQ-38

## 1. Requirement ID
REQ-38: Network contact handling for departments

## 2. Requirement Analysis

### Testability Assessment
- Semi-automatically testable
- Requires both automated validation and manual inspection
- This is implementation guidance rather than a strict conformance requirement

### Complexity
Moderate

### Prerequisites
- Test system must be configured with department contact information
- Access to FHIR server with capability to store and retrieve resources containing contact information
- Test data representing department contacts must be available

## 3. Test Implementation Strategy

### Required Inputs

#### Test Data Scenarios
1. Department Contact Example:
```json
{
  "name": {
    "text": "Patient Help Line",
    "family": "",
    "given": []
  }
}
```

2. Mixed Contact Types:
```json
{
  "contact": [
    {
      "name": {
        "text": "Emergency Department",
        "family": "",
        "given": []
      }
    },
    {
      "name": {
        "text": "Dr. Jane Smith",
        "family": "Smith",
        "given": ["Jane"]
      }
    }
  ]
}
```

### Required FHIR Operations
- GET operations to retrieve resources containing department contacts
- POST/PUT operations to create/update resources with department contacts

### Validation Criteria

#### Automated Checks
1. Verify that department contact entries have:
   - Non-empty name.text field containing department name
   - Empty or null family name
   - Empty or null given name array

2. Structure Validation:
   - Confirm contact.name element exists
   - Verify correct data types for all fields

#### Manual Inspection Points
1. Review that department names are appropriately placed in the text field
2. Verify that only organizational units/departments (not human contacts) follow this pattern
3. Check that the text representation makes sense for department identification

### Test Cases

1. Basic Department Contact Test
   - Input: Create resource with department contact
   - Expected: Contact structured correctly with empty name parts and populated text
   - Assertion: Validates against specified pattern

2. Mixed Contact Types Test
   - Input: Resource with both department and human contacts
   - Expected: Different contact types structured appropriately
   - Assertion: Department contacts follow pattern while human contacts maintain standard name structure

3. Edge Cases
   - Empty department name
   - Very long department names
   - Special characters in department names
   - Multiple department contacts in single resource

### Test Data Management
- Create test fixture with sample department contacts
- Include variety of department names and structures
- Maintain separate test data for human contacts for comparison

### Reporting Requirements
- Document any deviations from expected pattern
- Record specific instances where guidance was not followed
- Note any ambiguous cases requiring clarification

### Notes
- This is implementation guidance rather than a strict requirement
- Focus on proper usage patterns rather than pass/fail criteria
- Consider documenting best practices found during testing

---

<a id='req-39'></a>

### REQ-39: Organization contact handling for departments

**Description**: "When the contact is a department name, rather than a human (e.g., patient help line), include a blank family and given name, and provide the department name in contact.name.text."

**Actor**: Server

**Conformance**: None (Implementation guidance)

# Test Specification for REQ-39

## 1. Requirement ID
REQ-39: Organization contact handling for departments

## 2. Requirement Analysis

### Testability Assessment
- **Classification**: Automatically testable with manual verification
- **Rationale**: While automated tests can verify the structure of contact elements, human review may be needed to confirm proper usage of department names vs human names

### Complexity
Moderate

### Prerequisites
- Test system must support Organization resource creation/updates
- Sample department contact information
- Sample human contact information (for comparison)

## 3. Test Implementation Strategy

### Required Resources

#### Test Data
1. Organization resource with department contact:
```json
{
  "resourceType": "Organization",
  "contact": [{
    "name": {
      "text": "Patient Services Department",
      "family": "",
      "given": []
    }
  }]
}
```

2. Organization resource with human contact (for comparison):
```json
{
  "resourceType": "Organization",
  "contact": [{
    "name": {
      "family": "Smith",
      "given": ["John"]
    }
  }]
}
```

### Test Cases

#### Test Case 1: Department Contact Validation
**Purpose**: Verify correct handling of department name in contact.name.text

**Steps**:
1. Create Organization resource with department contact
2. Retrieve created resource
3. Verify contact name structure

**Validation Criteria**:
- contact.name.text SHALL contain department name
- contact.name.family SHALL be empty string
- contact.name.given SHALL be empty array

#### Test Case 2: Mixed Contact Types
**Purpose**: Verify system can handle both department and human contacts

**Steps**:
1. Create Organization resource with both department and human contacts
2. Retrieve created resource
3. Verify both contact types are structured correctly

**Validation Criteria**:
- Department contact follows department name pattern
- Human contact maintains standard name structure

### Required FHIR Operations
- POST /Organization (create)
- GET /Organization/{id} (read)

*Note: These operations are implied by the requirement but not explicitly mentioned in the Capability Statement. Implementation should verify actual system support.*

### Implementation Notes
1. Test implementations should include error handling for:
   - Missing contact information
   - Malformed contact structures
   - Invalid data types

2. Consider edge cases:
   - Multiple department contacts
   - Special characters in department names
   - Very long department names

### Validation Procedures
1. Automated Validation:
   - JSON structure validation
   - Empty family/given name verification
   - Presence of text element for department names

2. Manual Review:
   - Appropriate use of department vs human contact
   - Meaningful department names in text field

### Test Data Management
- Maintain test data sets for both department and human contacts
- Include edge cases in test data
- Document expected results for each test case

## Additional Considerations
1. This is implementation guidance rather than a strict conformance requirement
2. Local business rules may affect specific department naming conventions
3. Consider impact on UI display of contacts
4. Consider impact on search functionality when department names are stored in text field

---

<a id='req-40'></a>

### REQ-40: Practitioner qualification coding

**Description**: "When the value set for the coded concept in qualification is insufficient, the qualification can be provided in the text field of the codeableConcept."

**Actor**: Server

**Conformance**: None (Implementation guidance)

# Test Specification for REQ-40

## 1. Requirement ID
REQ-40: Practitioner qualification coding text usage

## 2. Requirement Analysis

### Testability Assessment
- Semi-automated testable (combination of automated validation and manual inspection)
- Requires manual review of text content appropriateness
- Can automate structure validation

### Complexity
Moderate

### Prerequisites
- FHIR server implementing Practitioner resource
- Test data set containing Practitioner resources with qualifications
- Access to approved qualification value sets
- Server must support Practitioner resource read operations

## 3. Test Implementation Strategy

### Required Inputs

#### Test Data
1. Practitioner resource with qualification using standard codes:
```json
{
  "resourceType": "Practitioner",
  "qualification": [{
    "code": {
      "coding": [{
        "system": "http://example.org/qualifications",
        "code": "standard-qual"
      }]
    }
  }]
}
```

2. Practitioner resource with qualification using text field:
```json
{
  "resourceType": "Practitioner",
  "qualification": [{
    "code": {
      "coding": [{
        "system": "http://example.org/qualifications",
        "code": "other"
      }],
      "text": "Specialized Nuclear Medicine Fellowship"
    }
  }]
}
```

### Required FHIR Operations
1. `GET [base]/Practitioner/[id]` - To retrieve test Practitioner resources
2. `POST [base]/Practitioner` - To create test resources (if testing write operations)

### Validation Criteria

#### Structural Validation
1. Verify Practitioner.qualification.code.coding exists when standard codes are used
2. Verify Practitioner.qualification.code.text is present when non-standard qualifications are specified
3. Verify the text field contains meaningful content (not empty or whitespace)

#### Content Validation
1. Manual review required to verify:
   - Text content is appropriate for the qualification context
   - Text is used only when standard codes are insufficient
   - Text provides clear, unambiguous qualification information

#### Test Cases

1. **Standard Qualification Code**
   - Input: Practitioner with standard qualification code
   - Expected: Valid resource with coded qualification
   - Assertion: No text field required

2. **Non-Standard Qualification**
   - Input: Practitioner with non-standard qualification
   - Expected: Valid resource with text description
   - Assertion: Text field present and meaningful

3. **Mixed Qualifications**
   - Input: Practitioner with both standard and non-standard qualifications
   - Expected: Valid resource with appropriate use of both coding and text
   - Assertion: Text used only where necessary

### Test Notes
- This is primarily implementation guidance rather than a strict conformance requirement
- Focus on appropriate usage of text field rather than enforcing its presence
- Consider documenting examples of appropriate vs inappropriate text usage for implementers
- Manual review component makes this unsuitable for fully automated testing
- Consider including in implementation guidance documentation rather than conformance test suite

---



